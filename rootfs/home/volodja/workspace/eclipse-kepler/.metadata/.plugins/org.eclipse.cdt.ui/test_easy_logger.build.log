09:33:26 **** Build of configuration Release for project test_easy_logger ****
make all 
Building file: ../main.cpp
Invoking: GCC C++ Compiler
g++ -O3 -Wall -c -fmessage-length=0 -MMD -MP -MF"main.d" -MT"main.d" -o "main.o" "../main.cpp"
In file included from /usr/include/c++/4.8/type_traits:35:0,
                 from ../easylogging++.h:320,
                 from ../main.cpp:12:
/usr/include/c++/4.8/bits/c++0x_warning.h:32:2: error: #error This file requires compiler and library support for the ISO C++ 2011 standard. This support is currently experimental, and must be enabled with the -std=c++11 or -std=gnu++11 compiler options.
 #error This file requires compiler and library support for the \
  ^
In file included from ../main.cpp:12:0:
../easylogging++.h:849:5: warning: identifier ‘nullptr’ is a keyword in C++11 [-Wc++0x-compat]
     if (pointer == nullptr)
     ^
In file included from ../main.cpp:12:0:
../easylogging++.h:445:9: error: ‘shared_ptr’ in namespace ‘std’ does not name a type
 typedef std::shared_ptr<base::Storage> StoragePointer;
         ^
../easylogging++.h:447:9: error: ‘shared_ptr’ in namespace ‘std’ does not name a type
 typedef std::shared_ptr<LogDispatchCallback> LogDispatchCallbackPtr;
         ^
../easylogging++.h:448:9: error: ‘shared_ptr’ in namespace ‘std’ does not name a type
 typedef std::shared_ptr<PerformanceTrackingCallback> PerformanceTrackingCallbackPtr;
         ^
../easylogging++.h:475:1: warning: scoped enums only available with -std=c++11 or -std=gnu++11 [enabled by default]
 enum class Level : base::type::EnumType {
 ^
../easylogging++.h:475:32: warning: scoped enums only available with -std=c++11 or -std=gnu++11 [enabled by default]
 enum class Level : base::type::EnumType {
                                ^
../easylogging++.h:499:85: error: ‘Level’ is not a class or namespace
     static const base::type::EnumType kMinValid = static_cast<base::type::EnumType>(Level::Trace);
                                                                                     ^
../easylogging++.h:501:85: error: ‘Level’ is not a class or namespace
     static const base::type::EnumType kMaxValid = static_cast<base::type::EnumType>(Level::Info);
                                                                                     ^
../easylogging++.h:550:77: error: ‘function’ in namespace ‘std’ does not name a type
     static inline void forEachLevel(base::type::EnumType* startIndex, const std::function<bool(void)>& fn) {
                                                                             ^
../easylogging++.h:550:82: error: ISO C++ forbids declaration of ‘parameter’ with no type [-fpermissive]
     static inline void forEachLevel(base::type::EnumType* startIndex, const std::function<bool(void)>& fn) {
                                                                                  ^
../easylogging++.h:550:90: error: expected ‘,’ or ‘...’ before ‘<’ token
     static inline void forEachLevel(base::type::EnumType* startIndex, const std::function<bool(void)>& fn) {
                                                                                          ^
../easylogging++.h: In static member function ‘static const char* el::LevelHelper::convertToString(el::Level)’:
../easylogging++.h:514:22: error: ‘Level’ is not a class or namespace
         if (level == Level::Global) return "GLOBAL";
                      ^
../easylogging++.h:515:22: error: ‘Level’ is not a class or namespace
         if (level == Level::Debug) return "DEBUG";
                      ^
../easylogging++.h:516:22: error: ‘Level’ is not a class or namespace
         if (level == Level::Info) return "INFO";
                      ^
../easylogging++.h:517:22: error: ‘Level’ is not a class or namespace
         if (level == Level::Warning) return "WARNING";
                      ^
../easylogging++.h:518:22: error: ‘Level’ is not a class or namespace
         if (level == Level::Error) return "ERROR";
                      ^
../easylogging++.h:519:22: error: ‘Level’ is not a class or namespace
         if (level == Level::Fatal) return "FATAL";
                      ^
../easylogging++.h:520:22: error: ‘Level’ is not a class or namespace
         if (level == Level::Verbose) return "VERBOSE";
                      ^
../easylogging++.h:521:22: error: ‘Level’ is not a class or namespace
         if (level == Level::Trace) return "TRACE";
                      ^
../easylogging++.h: In static member function ‘static el::Level el::LevelHelper::convertFromString(const char*)’:
../easylogging++.h:529:20: error: ‘Level’ is not a class or namespace
             return Level::Global;
                    ^
../easylogging++.h:531:20: error: ‘Level’ is not a class or namespace
             return Level::Debug;
                    ^
../easylogging++.h:533:20: error: ‘Level’ is not a class or namespace
             return Level::Info;
                    ^
../easylogging++.h:535:20: error: ‘Level’ is not a class or namespace
             return Level::Warning;
                    ^
../easylogging++.h:537:20: error: ‘Level’ is not a class or namespace
             return Level::Error;
                    ^
../easylogging++.h:539:20: error: ‘Level’ is not a class or namespace
             return Level::Fatal;
                    ^
../easylogging++.h:541:20: error: ‘Level’ is not a class or namespace
             return Level::Verbose;
                    ^
../easylogging++.h:543:20: error: ‘Level’ is not a class or namespace
             return Level::Trace;
                    ^
../easylogging++.h:544:16: error: ‘Level’ is not a class or namespace
         return Level::Unknown;
                ^
../easylogging++.h: In static member function ‘static void el::LevelHelper::forEachLevel(el::base::type::EnumType*, int)’:
../easylogging++.h:553:20: error: ‘fn’ was not declared in this scope
             if (fn()) {
                    ^
../easylogging++.h: At global scope:
../easylogging++.h:562:1: warning: scoped enums only available with -std=c++11 or -std=gnu++11 [enabled by default]
 enum class ConfigurationType : base::type::EnumType {
 ^
../easylogging++.h:562:44: warning: scoped enums only available with -std=c++11 or -std=gnu++11 [enabled by default]
 enum class ConfigurationType : base::type::EnumType {
                                            ^
../easylogging++.h:595:85: error: ‘ConfigurationType’ is not a class or namespace
     static const base::type::EnumType kMinValid = static_cast<base::type::EnumType>(ConfigurationType::Enabled);
                                                                                     ^
../easylogging++.h:597:85: error: ‘ConfigurationType’ is not a class or namespace
     static const base::type::EnumType kMaxValid = static_cast<base::type::EnumType>(ConfigurationType::MaxLogFileSize);
                                                                                     ^
../easylogging++.h:650:82: error: ‘function’ in namespace ‘std’ does not name a type
     static inline void forEachConfigType(base::type::EnumType* startIndex, const std::function<bool(void)>& fn) {
                                                                                  ^
../easylogging++.h:650:87: error: ISO C++ forbids declaration of ‘parameter’ with no type [-fpermissive]
     static inline void forEachConfigType(base::type::EnumType* startIndex, const std::function<bool(void)>& fn) {
                                                                                       ^
../easylogging++.h:650:95: error: expected ‘,’ or ‘...’ before ‘<’ token
     static inline void forEachConfigType(base::type::EnumType* startIndex, const std::function<bool(void)>& fn) {
                                                                                               ^
../easylogging++.h: In static member function ‘static const char* el::ConfigurationTypeHelper::convertToString(el::ConfigurationType)’:
../easylogging++.h:610:34: error: ‘ConfigurationType’ is not a class or namespace
         if (configurationType == ConfigurationType::Enabled) return "ENABLED";
                                  ^
../easylogging++.h:611:34: error: ‘ConfigurationType’ is not a class or namespace
         if (configurationType == ConfigurationType::Filename) return "FILENAME";
                                  ^
../easylogging++.h:612:34: error: ‘ConfigurationType’ is not a class or namespace
         if (configurationType == ConfigurationType::Format) return "FORMAT";
                                  ^
../easylogging++.h:613:34: error: ‘ConfigurationType’ is not a class or namespace
         if (configurationType == ConfigurationType::ToFile) return "TO_FILE";
                                  ^
../easylogging++.h:614:34: error: ‘ConfigurationType’ is not a class or namespace
         if (configurationType == ConfigurationType::ToStandardOutput) return "TO_STANDARD_OUTPUT";
                                  ^
../easylogging++.h:615:34: error: ‘ConfigurationType’ is not a class or namespace
         if (configurationType == ConfigurationType::MillisecondsWidth) return "MILLISECONDS_WIDTH";
                                  ^
../easylogging++.h:616:34: error: ‘ConfigurationType’ is not a class or namespace
         if (configurationType == ConfigurationType::PerformanceTracking) return "PERFORMANCE_TRACKING";
                                  ^
../easylogging++.h:617:34: error: ‘ConfigurationType’ is not a class or namespace
         if (configurationType == ConfigurationType::MaxLogFileSize) return "MAX_LOG_FILE_SIZE";
                                  ^
../easylogging++.h:618:34: error: ‘ConfigurationType’ is not a class or namespace
         if (configurationType == ConfigurationType::LogFlushThreshold) return "LOG_FLUSH_THRESHOLD";
                                  ^
../easylogging++.h: In static member function ‘static el::ConfigurationType el::ConfigurationTypeHelper::convertFromString(const char*)’:
../easylogging++.h:626:20: error: ‘ConfigurationType’ is not a class or namespace
             return ConfigurationType::Enabled;
                    ^
../easylogging++.h:628:20: error: ‘ConfigurationType’ is not a class or namespace
             return ConfigurationType::ToFile;
                    ^
../easylogging++.h:630:20: error: ‘ConfigurationType’ is not a class or namespace
             return ConfigurationType::ToStandardOutput;
                    ^
../easylogging++.h:632:20: error: ‘ConfigurationType’ is not a class or namespace
             return ConfigurationType::Format;
                    ^
../easylogging++.h:634:20: error: ‘ConfigurationType’ is not a class or namespace
             return ConfigurationType::Filename;
                    ^
../easylogging++.h:636:20: error: ‘ConfigurationType’ is not a class or namespace
             return ConfigurationType::MillisecondsWidth;
                    ^
../easylogging++.h:638:20: error: ‘ConfigurationType’ is not a class or namespace
             return ConfigurationType::PerformanceTracking;
                    ^
../easylogging++.h:640:20: error: ‘ConfigurationType’ is not a class or namespace
             return ConfigurationType::MaxLogFileSize;
                    ^
../easylogging++.h:642:20: error: ‘ConfigurationType’ is not a class or namespace
             return ConfigurationType::LogFlushThreshold;
                    ^
../easylogging++.h:643:16: error: ‘ConfigurationType’ is not a class or namespace
         return ConfigurationType::Unknown;
                ^
../easylogging++.h: In static member function ‘static void el::ConfigurationTypeHelper::forEachConfigType(el::base::type::EnumType*, int)’:
../easylogging++.h:653:20: error: ‘fn’ was not declared in this scope
             if (fn()) {
                    ^
../easylogging++.h: At global scope:
../easylogging++.h:661:1: warning: scoped enums only available with -std=c++11 or -std=gnu++11 [enabled by default]
 enum class LoggingFlag : base::type::EnumType {
 ^
../easylogging++.h:661:38: warning: scoped enums only available with -std=c++11 or -std=gnu++11 [enabled by default]
 enum class LoggingFlag : base::type::EnumType {
                                      ^
In file included from ../main.cpp:12:0:
../easylogging++.h:774:71: error: ‘Level’ is not a class or namespace
     static const Level kPerformanceTrackerDefaultLevel         =      Level::Info;
                                                                       ^
../easylogging++.h:808:9: error: ‘function’ in namespace ‘std’ does not name a type
 typedef std::function<void(const char*, std::size_t)> PreRollOutCallback;
         ^
../easylogging++.h:812:1: warning: scoped enums only available with -std=c++11 or -std=gnu++11 [enabled by default]
 enum class TimestampUnit : base::type::EnumType {
 ^
../easylogging++.h:812:40: warning: scoped enums only available with -std=c++11 or -std=gnu++11 [enabled by default]
 enum class TimestampUnit : base::type::EnumType {
                                        ^
../easylogging++.h:816:1: warning: scoped enums only available with -std=c++11 or -std=gnu++11 [enabled by default]
 enum class FormatFlags : base::type::EnumType {
 ^
../easylogging++.h:816:38: warning: scoped enums only available with -std=c++11 or -std=gnu++11 [enabled by default]
 enum class FormatFlags : base::type::EnumType {
                                      ^
../easylogging++.h:847:15: error: ‘enable_if’ in namespace ‘std’ does not name a type
 typename std::enable_if<std::is_pointer<T*>::value, void>::type
               ^
../easylogging++.h:847:24: error: expected unqualified-id before ‘<’ token
 typename std::enable_if<std::is_pointer<T*>::value, void>::type
                        ^
../easylogging++.h: In function ‘const char* el::base::utils::charPtrVal(const char*)’:
../easylogging++.h:856:23: error: ‘nullptr’ was not declared in this scope
     return pointer == nullptr ? base::consts::kNullPointer : pointer;
                       ^
../easylogging++.h: At global scope:
../easylogging++.h:1021:41: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual inline void acquireLock(void) ELPP_FINAL { m_mutex.lock(); }
                                         ^
../easylogging++.h:1022:41: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual inline void releaseLock(void) ELPP_FINAL { m_mutex.unlock(); }
                                         ^
../easylogging++.h:1023:53: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual inline base::threading::Mutex& lock(void) ELPP_FINAL { return m_mutex; }
                                                     ^
../easylogging++.h: In static member function ‘static el::base::type::fstream_t* el::base::utils::File::newFileStream(const string&)’:
../easylogging++.h:1046:13: error: ‘safeDelete’ is not a member of ‘el::base::utils’
             base::utils::safeDelete(fs);
             ^
../easylogging++.h: In static member function ‘static std::size_t el::base::utils::File::getSizeOfFile(el::base::type::fstream_t*)’:
../easylogging++.h:1054:19: error: ‘nullptr’ was not declared in this scope
         if (fs == nullptr) {
                   ^
../easylogging++.h: In static member function ‘static bool el::base::utils::File::pathExists(const char*, bool)’:
../easylogging++.h:1066:21: error: ‘nullptr’ was not declared in this scope
         if (path == nullptr) {
                     ^
../easylogging++.h: In static member function ‘static bool el::base::utils::File::createPath(const string&)’:
../easylogging++.h:1106:28: error: ‘nullptr’ was not declared in this scope
         while (currPath != nullptr) {
                            ^
../easylogging++.h: In static member function ‘static bool el::base::utils::Str::cStringEq(const char*, const char*)’:
../easylogging++.h:1274:19: error: ‘nullptr’ was not declared in this scope
         if (s1 == nullptr && s2 == nullptr) return true;
                   ^
../easylogging++.h:1275:19: error: ‘nullptr’ was not declared in this scope
         if (s1 == nullptr || s2 == nullptr) return false;
                   ^
../easylogging++.h: In static member function ‘static bool el::base::utils::Str::cStringCaseEq(const char*, const char*)’:
../easylogging++.h:1282:19: error: ‘nullptr’ was not declared in this scope
         if (s1 == nullptr && s2 == nullptr) return true;
                   ^
../easylogging++.h:1283:19: error: ‘nullptr’ was not declared in this scope
         if (s1 == nullptr || s2 == nullptr) return false;
                   ^
../easylogging++.h: At global scope:
../easylogging++.h:1418:134: error: ‘nullptr’ was not declared in this scope
     static std::string getEnvironmentVariable(const char* variableName, const char* defaultVal, const char* alternativeBashCommand = nullptr) {
                                                                                                                                      ^
../easylogging++.h: In static member function ‘static const string el::base::utils::OS::getBashOutput(const char*)’:
../easylogging++.h:1390:24: error: ‘nullptr’ was not declared in this scope
         if (command == nullptr) {
                        ^
../easylogging++.h:1393:22: error: ‘nullptr’ was not declared in this scope
         FILE* proc = nullptr;
                      ^
../easylogging++.h: In static member function ‘static std::string el::base::utils::OS::getEnvironmentVariable(const char*, const char*, const char*)’:
../easylogging++.h:1424:21: error: ‘nullptr’ was not declared in this scope
         if ((val == nullptr) || ((strcmp(val, "") == 0))) {
                     ^
../easylogging++.h: In static member function ‘static bool el::base::utils::OS::termSupportsColor()’:
../easylogging++.h:1471:61: error: call to ‘static std::string el::base::utils::OS::getEnvironmentVariable(const char*, const char*, const char*)’ uses the default argument for parameter 3, which is not yet defined
         std::string term = getEnvironmentVariable("TERM", "");
                                                             ^
../easylogging++.h: In static member function ‘static void el::base::utils::DateTime::gettimeofday(timeval*)’:
../easylogging++.h:1519:28: error: ‘nullptr’ was not declared in this scope
         ::gettimeofday(tv, nullptr);
                            ^
../easylogging++.h: In static member function ‘static long long unsigned int el::base::utils::DateTime::getTimeDifference(const timeval&, const timeval&, el::base::TimestampUnit)’:
../easylogging++.h:1557:36: error: ‘el::base::TimestampUnit’ is not a class or namespace
         if (timestampUnit == base::TimestampUnit::Microsecond) {
                                    ^
../easylogging++.h: In constructor ‘el::base::utils::CommandLineArgs::CommandLineArgs()’:
../easylogging++.h:1655:40: error: ‘nullptr’ was not declared in this scope
         setArgs(0, static_cast<char**>(nullptr));
                                        ^
../easylogging++.h: In member function ‘void el::base::utils::CommandLineArgs::setArgs(int, char**)’:
../easylogging++.h:1672:34: error: ‘nullptr’ was not declared in this scope
         if (argc == 0 || argv == nullptr) {
                                  ^
../easylogging++.h:1679:22: error: ‘nullptr’ was not declared in this scope
             if (v != nullptr && strlen(v) > 0) {
                      ^
../easylogging++.h:1689:22: error: ‘nullptr’ was not declared in this scope
             if (v == nullptr) {
                      ^
../easylogging++.h: At global scope:
../easylogging++.h:1751:38: error: expected ‘,’ or ‘...’ before ‘&&’ token
     AbstractRegistry(AbstractRegistry&& sr) {
                                      ^
../easylogging++.h:1751:43: error: invalid constructor; you probably meant ‘el::base::utils::AbstractRegistry<T_Ptr, Container> (const el::base::utils::AbstractRegistry<T_Ptr, Container>&)’
     AbstractRegistry(AbstractRegistry&& sr) {
                                           ^
../easylogging++.h:1784:49: error: expected ‘,’ or ‘...’ before ‘&&’ token
     AbstractRegistry& operator=(AbstractRegistry&& sr) {
                                                 ^
../easylogging++.h:1797:39: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual inline iterator begin(void) ELPP_FINAL {
                                       ^
../easylogging++.h:1802:37: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual inline iterator end(void) ELPP_FINAL {
                                     ^
../easylogging++.h:1808:48: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual inline const_iterator cbegin(void) const ELPP_FINAL {
                                                ^
../easylogging++.h:1813:46: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual inline const_iterator cend(void) const ELPP_FINAL {
                                              ^
../easylogging++.h:1818:37: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual inline bool empty(void) const ELPP_FINAL {
                                     ^
../easylogging++.h:1823:43: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual inline std::size_t size(void) const ELPP_FINAL {
                                           ^
../easylogging++.h:1828:40: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual inline Container& list(void) ELPP_FINAL {
                                        ^
../easylogging++.h:1833:48: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual inline const Container& list(void) const ELPP_FINAL {
                                                ^
../easylogging++.h:1751:5: error: cannot declare parameter ‘<anonymous>’ to be of abstract type ‘el::base::utils::AbstractRegistry<T_Ptr, Container>’
     AbstractRegistry(AbstractRegistry&& sr) {
     ^
../easylogging++.h:1742:7: note:   because the following virtual functions are pure within ‘el::base::utils::AbstractRegistry<T_Ptr, Container>’:
 class AbstractRegistry : public base::threading::ThreadSafe {
       ^
../easylogging++.h:1838:18: note: 	virtual void el::base::utils::AbstractRegistry<T_Ptr, Container>::unregisterAll()
     virtual void unregisterAll(void) = 0;
                  ^
../easylogging++.h:1841:18: note: 	virtual void el::base::utils::AbstractRegistry<T_Ptr, Container>::deepCopy(const el::base::utils::AbstractRegistry<T_Ptr, Container>&)
     virtual void deepCopy(const AbstractRegistry<T_Ptr, Container>&) = 0;
                  ^
../easylogging++.h:1784:23: error: cannot declare parameter ‘<anonymous>’ to be of abstract type ‘el::base::utils::AbstractRegistry<T_Ptr, Container>’
     AbstractRegistry& operator=(AbstractRegistry&& sr) {
                       ^
../easylogging++.h:1742:7: note:   since type ‘el::base::utils::AbstractRegistry<T_Ptr, Container>’ has pure virtual functions
 class AbstractRegistry : public base::threading::ThreadSafe {
       ^
../easylogging++.h: In member function ‘el::base::utils::AbstractRegistry<T_Ptr, Container>& el::base::utils::AbstractRegistry<T_Ptr, Container>::operator=(el::base::utils::AbstractRegistry<T_Ptr, Container>)’:
../easylogging++.h:1785:22: error: ‘sr’ was not declared in this scope
         if (this == &sr) {
                      ^
../easylogging++.h:1789:18: error: ‘move’ is not a member of ‘std’
         m_list = std::move(sr.m_list);
                  ^
../easylogging++.h:1789:28: error: ‘sr’ was not declared in this scope
         m_list = std::move(sr.m_list);
                            ^
../easylogging++.h: At global scope:
../easylogging++.h:1857:71: error: ‘>>’ should be ‘> >’ within a nested template argument list
 class Registry : public AbstractRegistry<T_Ptr, std::map<T_Key, T_Ptr*>> {
                                                                       ^
../easylogging++.h:1888:43: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual inline void unregisterAll(void) ELPP_FINAL {
                                           ^
../easylogging++.h:1898:69: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual inline void registerNew(const T_Key& uniqKey, T_Ptr* ptr) ELPP_FINAL {
                                                                     ^
../easylogging++.h:1921:86: error: ‘>>’ should be ‘> >’ within a nested template argument list
     virtual inline void deepCopy(const AbstractRegistry<T_Ptr, std::map<T_Key, T_Ptr*>>& sr) ELPP_FINAL {
                                                                                      ^
../easylogging++.h:1921:92: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual inline void deepCopy(const AbstractRegistry<T_Ptr, std::map<T_Key, T_Ptr*>>& sr) ELPP_FINAL {
                                                                                            ^
../easylogging++.h: In copy constructor ‘el::base::utils::Registry<T_Ptr, T_Key>::Registry(const el::base::utils::Registry<T_Ptr, T_Key>&)’:
../easylogging++.h:1865:78: error: ‘>>’ should be ‘> >’ within a nested template argument list
     Registry(const Registry& sr) : AbstractRegistry<T_Ptr, std::vector<T_Ptr*>>() {
                                                                              ^
../easylogging++.h: In member function ‘virtual void el::base::utils::Registry<T_Ptr, T_Key>::unregisterAll()’:
../easylogging++.h:1890:18: warning: ‘auto’ changes meaning in C++11; please remove it [-Wc++0x-compat]
             for (auto&& curr : this->list()) {
                  ^
../easylogging++.h:1890:22: error: expected unqualified-id before ‘&&’ token
             for (auto&& curr : this->list()) {
                      ^
../easylogging++.h:1890:22: error: expected ‘;’ before ‘&&’ token
../easylogging++.h:1890:30: error: expected ‘;’ before ‘:’ token
             for (auto&& curr : this->list()) {
                              ^
../easylogging++.h:1890:30: error: expected primary-expression before ‘:’ token
../easylogging++.h:1890:30: error: expected ‘)’ before ‘:’ token
../easylogging++.h:1890:30: error: expected primary-expression before ‘:’ token
../easylogging++.h:1890:30: error: expected ‘;’ before ‘:’ token
../easylogging++.h: In member function ‘void el::base::utils::Registry<T_Ptr, T_Key>::unregister(const T_Key&)’:
../easylogging++.h:1906:25: error: ‘nullptr’ was not declared in this scope
         if (existing != nullptr) {
                         ^
../easylogging++.h:1907:13: error: ‘safeDelete’ is not a member of ‘el::base::utils’
             base::utils::safeDelete(existing);
             ^
../easylogging++.h: In member function ‘T_Ptr* el::base::utils::Registry<T_Ptr, T_Key>::get(const T_Key&)’:
../easylogging++.h:1916:19: error: ‘nullptr’ was not declared in this scope
                 ? nullptr
                   ^
../easylogging++.h: At global scope:
../easylogging++.h:1933:75: error: ‘>>’ should be ‘> >’ within a nested template argument list
 class RegistryWithPred : public AbstractRegistry<T_Ptr, std::vector<T_Ptr*>> {
                                                                           ^
../easylogging++.h:1972:43: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual inline void unregisterAll(void) ELPP_FINAL {
                                           ^
../easylogging++.h:1981:40: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual void unregister(T_Ptr*& ptr) ELPP_FINAL {  // NOLINT
                                        ^
../easylogging++.h:1996:47: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual inline void registerNew(T_Ptr* ptr) ELPP_FINAL {
                                               ^
../easylogging++.h:2012:82: error: ‘>>’ should be ‘> >’ within a nested template argument list
     virtual inline void deepCopy(const AbstractRegistry<T_Ptr, std::vector<T_Ptr*>>& sr) {
                                                                                  ^
../easylogging++.h: In copy constructor ‘el::base::utils::RegistryWithPred<T_Ptr, Pred>::RegistryWithPred(const el::base::utils::RegistryWithPred<T_Ptr, Pred>&)’:
../easylogging++.h:1946:94: error: ‘>>’ should be ‘> >’ within a nested template argument list
     RegistryWithPred(const RegistryWithPred& sr) : AbstractRegistry<T_Ptr, std::vector<T_Ptr*>>() {
                                                                                              ^
../easylogging++.h: In member function ‘virtual void el::base::utils::RegistryWithPred<T_Ptr, Pred>::unregisterAll()’:
../easylogging++.h:1974:18: warning: ‘auto’ changes meaning in C++11; please remove it [-Wc++0x-compat]
             for (auto&& curr : this->list()) {
                  ^
../easylogging++.h:1974:22: error: expected unqualified-id before ‘&&’ token
             for (auto&& curr : this->list()) {
                      ^
../easylogging++.h:1974:22: error: expected ‘;’ before ‘&&’ token
../easylogging++.h:1974:30: error: expected ‘;’ before ‘:’ token
             for (auto&& curr : this->list()) {
                              ^
../easylogging++.h:1974:30: error: expected primary-expression before ‘:’ token
../easylogging++.h:1974:30: error: expected ‘)’ before ‘:’ token
../easylogging++.h:1974:30: error: expected primary-expression before ‘:’ token
../easylogging++.h:1974:30: error: expected ‘;’ before ‘:’ token
../easylogging++.h: In member function ‘virtual void el::base::utils::RegistryWithPred<T_Ptr, Pred>::unregister(T_Ptr*&)’:
../easylogging++.h:1989:49: error: ‘nullptr’ was not declared in this scope
             if (iter != this->end() && *iter != nullptr) {
                                                 ^
../easylogging++.h:1991:17: error: ‘safeDelete’ is not a member of ‘el::base::utils’
                 base::utils::safeDelete(*iter);
                 ^
../easylogging++.h: In member function ‘T_Ptr* el::base::utils::RegistryWithPred<T_Ptr, Pred>::get(const T&, T2)’:
../easylogging++.h:2005:52: error: ‘nullptr’ was not declared in this scope
         if (iter != this->list().end() && *iter != nullptr) {
                                                    ^
../easylogging++.h:2008:16: error: ‘nullptr’ was not declared in this scope
         return nullptr;
                ^
../easylogging++.h: At global scope:
../easylogging++.h:2059:24: error: expected ‘,’ or ‘...’ before ‘&&’ token
     LogFormat(LogFormat&& logFormat) {
                        ^
../easylogging++.h:2059:36: error: invalid constructor; you probably meant ‘el::base::LogFormat (const el::base::LogFormat&)’
     LogFormat(LogFormat&& logFormat) {
                                    ^
../easylogging++.h:2165:86: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual void updateDateFormat(std::size_t index, base::type::string_t& currFormat) ELPP_FINAL {  // NOLINT
                                                                                      ^
../easylogging++.h:2193:39: warning: override controls (override/final) only available with -std=c++11 or -std=gnu++11 [enabled by default]
     virtual void updateFormatSpec(void) ELPP_FINAL {
                                       ^
../easylogging++.h: In constructor ‘el::base::LogFormat::LogFormat()’:
../easylogging++.h:2039:17: error: ‘Level’ is not a class or namespace
         m_level(Level::Unknown),
                 ^
../easylogging++.h: In member function ‘void el::base::LogFormat::parseFromFormat(const string_t&)’:
../easylogging++.h:2091:9: warning: ‘auto’ changes meaning in C++11; please remove it [-Wc++0x-compat]
         auto conditionalAddFlag = [&](const base::type::char_t* specifier, base::FormatFlags flag) {
         ^
../easylogging++.h:2091:14: error: ‘conditionalAddFlag’ does not name a type
         auto conditionalAddFlag = [&](const base::type::char_t* specifier, base::FormatFlags flag) {
              ^
../easylogging++.h:2106:73: error: ‘el::base::FormatFlags’ is not a class or namespace
         conditionalAddFlag(base::consts::kAppNameFormatSpecifier, base::FormatFlags::AppName);
                                                                         ^
../easylogging++.h:2106:93: error: ‘conditionalAddFlag’ was not declared in this scope
         conditionalAddFlag(base::consts::kAppNameFormatSpecifier, base::FormatFlags::AppName);
                                                                                             ^
../easylogging++.h:2107:79: error: ‘el::base::FormatFlags’ is not a class or namespace
         conditionalAddFlag(base::consts::kSeverityLevelFormatSpecifier, base::FormatFlags::Level);
                                                                               ^
../easylogging++.h:2108:74: error: ‘el::base::FormatFlags’ is not a class or namespace
         conditionalAddFlag(base::consts::kLoggerIdFormatSpecifier, base::FormatFlags::LoggerId);
                                                                          ^
../easylogging++.h:2109:74: error: ‘el::base::FormatFlags’ is not a class or namespace
         conditionalAddFlag(base::consts::kThreadIdFormatSpecifier, base::FormatFlags::ThreadId);
                                                                          ^
../easylogging++.h:2110:73: error: ‘el::base::FormatFlags’ is not a class or namespace
         conditionalAddFlag(base::consts::kLogFileFormatSpecifier, base::FormatFlags::File);
                                                                         ^
../easylogging++.h:2111:73: error: ‘el::base::FormatFlags’ is not a class or namespace
         conditionalAddFlag(base::consts::kLogLineFormatSpecifier, base::FormatFlags::Line);
                                                                         ^
../easylogging++.h:2112:77: error: ‘el::base::FormatFlags’ is not a class or namespace
         conditionalAddFlag(base::consts::kLogLocationFormatSpecifier, base::FormatFlags::Location);
                                                                             ^
../easylogging++.h:2113:77: error: ‘el::base::FormatFlags’ is not a class or namespace
         conditionalAddFlag(base::consts::kLogFunctionFormatSpecifier, base::FormatFlags::Function);
                                                                             ^
../easylogging++.h:2114:77: error: ‘el::base::FormatFlags’ is not a class or namespace
         conditionalAddFlag(base::consts::kCurrentUserFormatSpecifier, base::FormatFlags::User);
                                                                             ^
../easylogging++.h:2115:77: error: ‘el::base::FormatFlags’ is not a class or namespace
         conditionalAddFlag(base::consts::kCurrentHostFormatSpecifier, base::FormatFlags::Host);
                                                                             ^
../easylogging++.h:2116:73: error: ‘el::base::FormatFlags’ is not a class or namespace
         conditionalAddFlag(base::consts::kMessageFormatSpecifier, base::FormatFlags::LogMessage);
                                                                         ^
../easylogging++.h:2117:78: error: ‘el::base::FormatFlags’ is not a class or namespace
         conditionalAddFlag(base::consts::kVerboseLevelFormatSpecifier, base::FormatFlags::VerboseLevel);
                                                                              ^
../easylogging++.h:2125:31: error: ‘el::base::FormatFlags’ is not a class or namespace
                 addFlag(base::FormatFlags::DateTime);
                               ^
../easylogging++.h: In member function ‘virtual void el::base::LogFormat::updateDateFormat(std::size_t, el::base::type::string_t&)’:
../easylogging++.h:2166:27: error: ‘el::base::FormatFlags’ is not a class or namespace
         if (hasFlag(base::FormatFlags::DateTime)) {
                           ^
../easylogging++.h:2186:31: error: ‘el::base::FormatFlags’ is not a class or namespace
             if (hasFlag(base::FormatFlags::DateTime)) {
                               ^
../easylogging++.h: In member function ‘virtual void el::base::LogFormat::updateFormatSpec()’:
../easylogging++.h:2195:24: error: ‘Level’ is not a class or namespace
         if (m_level == Level::Debug) {
                        ^
../easylogging++.h:2198:31: error: ‘Level’ is not a class or namespace
         } else if (m_level == Level::Info) {
                               ^
../easylogging++.h:2201:31: error: ‘Level’ is not a class or namespace
         } else if (m_level == Level::Warning) {
                               ^
../easylogging++.h:2204:31: error: ‘Level’ is not a class or namespace
         } else if (m_level == Level::Error) {
                               ^
../easylogging++.h:2207:31: error: ‘Level’ is not a class or namespace
         } else if (m_level == Level::Fatal) {
                               ^
../easylogging++.h:2210:31: error: ‘Level’ is not a class or namespace
         } else if (m_level == Level::Verbose) {
                               ^
../easylogging++.h:2213:31: error: ‘Level’ is not a class or namespace
         } else if (m_level == Level::Trace) {
                               ^
../easylogging++.h:2217:27: error: ‘el::base::FormatFlags’ is not a class or namespace
         if (hasFlag(base::FormatFlags::User)) {
                           ^
../easylogging++.h:2222:27: error: ‘el::base::FormatFlags’ is not a class or namespace
         if (hasFlag(base::FormatFlags::Host)) {
                           ^
../easylogging++.h: At global scope:
../easylogging++.h:2243:9: error: ‘function’ in namespace ‘std’ does not name a type
 typedef std::function<const char*(void)> FormatSpecifierValueResolver;
         ^
../easylogging++.h:2249:62: error: ‘FormatSpecifierValueResolver’ does not name a type
     CustomFormatSpecifier(const char* formatSpecifier, const FormatSpecifierValueResolver& resolver) :
                                                              ^
../easylogging++.h:2249:92: error: ISO C++ forbids declaration of ‘resolver’ with no type [-fpermissive]
     CustomFormatSpecifier(const char* formatSpecifier, const FormatSpecifierValueResolver& resolver) :
                                                                                            ^
../easylogging++.h:2252:18: error: ‘FormatSpecifierValueResolver’ does not name a type
     inline const FormatSpecifierValueResolver& resolver(void) const { return m_resolver; }
                  ^
../easylogging++.h:2259:5: error: ‘FormatSpecifierValueResolver’ does not name a type
     FormatSpecifierValueResolver m_resolver;
     ^
../easylogging++.h: In constructor ‘el::CustomFormatSpecifier::CustomFormatSpecifier(const char*, const int&)’:
../easylogging++.h:2250:45: error: class ‘el::CustomFormatSpecifier’ does not have any field named ‘m_resolver’
         m_formatSpecifier(formatSpecifier), m_resolver(resolver) {}
                                             ^
../easylogging++.h: In member function ‘bool el::Configuration::Predicate::operator()(const el::Configuration*) const’:
../easylogging++.h:2332:30: error: ‘nullptr’ was not declared in this scope
             return ((conf != nullptr) && (conf->level() == m_level) && (conf->configurationType() == m_configurationType));
                              ^
../easylogging++.h: In instantiation of ‘class el::base::utils::AbstractRegistry<el::Configuration, std::vector<el::Configuration*, std::allocator<el::Configuration*> > >’:
../easylogging++.h:1933:7:   required from ‘class el::base::utils::RegistryWithPred<el::Configuration, el::Configuration::Predicate>’
../easylogging++.h:2349:44:   required from here
../easylogging++.h:1784:23: error: cannot allocate an object of abstract type ‘el::base::utils::AbstractRegistry<el::Configuration, std::vector<el::Configuration*, std::allocator<el::Configuration*> > >’
     AbstractRegistry& operator=(AbstractRegistry&& sr) {
                       ^
../easylogging++.h:1742:7: note:   because the following virtual functions are pure within ‘el::base::utils::AbstractRegistry<el::Configuration, std::vector<el::Configuration*, std::allocator<el::Configuration*> > >’:
 class AbstractRegistry : public base::threading::ThreadSafe {
       ^
../easylogging++.h:1838:18: note: 	void el::base::utils::AbstractRegistry<T_Ptr, Container>::unregisterAll() [with T_Ptr = el::Configuration; Container = std::vector<el::Configuration*, std::allocator<el::Configuration*> >]
     virtual void unregisterAll(void) = 0;
                  ^
../easylogging++.h:1841:18: note: 	void el::base::utils::AbstractRegistry<T_Ptr, Container>::deepCopy(const el::base::utils::AbstractRegistry<T_Ptr, Container>&) [with T_Ptr = el::Configuration; Container = std::vector<el::Configuration*, std::allocator<el::Configuration*> >]
     virtual void deepCopy(const AbstractRegistry<T_Ptr, Container>&) = 0;
                  ^
../easylogging++.h: At global scope:
../easylogging++.h:2363:118: error: ‘nullptr’ was not declared in this scope
     Configurations(const std::string& configurationFile, bool useDefaultsForRemaining = true, Configurations* base = nullptr) :
                                                                                                                      ^
../easylogging++.h:2381:92: error: ‘nullptr’ was not declared in this scope
     inline bool parseFromFile(const std::string& configurationFile, Configurations* base = nullptr) {
                                                                                            ^
../easylogging++.h:2401:95: error: ‘nullptr’ was not declared in this scope
     inline bool parseFromText(const std::string& configurationsString, Configurations* base = nullptr) {
                                                                                               ^
../easylogging++.h:2571:120: error: ‘nullptr’ was not declared in this scope
         static bool parseFromFile(const std::string& configurationFile, Configurations* sender, Configurations* base = nullptr) {
                                                                                                                        ^
../easylogging++.h:2598:123: error: ‘nullptr’ was not declared in this scope
         static bool parseFromText(const std::string& configurationsString, Configurations* sender, Configurations* base = nullptr) {
                                                                                                                           ^
../easylogging++.h: In member function ‘void el::Configurations::setFromBase(el::Configurations*)’:
../easylogging++.h:2412:21: error: ‘nullptr’ was not declared in this scope
         if (base == nullptr || base == this) {
                     ^
../easylogging++.h:2416:37: error: range-based ‘for’ loops are not allowed in C++98 mode
         for (Configuration*& conf : base->list()) {
                                     ^
../easylogging++.h: In member function ‘bool el::Configurations::hasConfiguration(el::ConfigurationType)’:
../easylogging++.h:2433:9: warning: lambda expressions only available with -std=c++11 or -std=gnu++11 [enabled by default]
         });
         ^
../easylogging++.h:2433:10: error: no matching function for call to ‘el::LevelHelper::forEachLevel(el::base::type::EnumType*, el::Configurations::hasConfiguration(el::ConfigurationType)::__lambda0)’
         });
          ^
../easylogging++.h:2433:10: note: candidate is:
In file included from ../main.cpp:12:0:
../easylogging++.h:550:24: note: static void el::LevelHelper::forEachLevel(el::base::type::EnumType*, int)
     static inline void forEachLevel(base::type::EnumType* startIndex, const std::function<bool(void)>& fn) {
                        ^
../easylogging++.h:550:24: note:   no known conversion for argument 2 from ‘el::Configurations::hasConfiguration(el::ConfigurationType)::__lambda0’ to ‘int’
In file included from ../main.cpp:12:0:
../easylogging++.h: In member function ‘bool el::Configurations::hasConfiguration(el::Level, el::ConfigurationType)’:
../easylogging++.h:2447:108: error: ‘nullptr’ was not declared in this scope
         return RegistryWithPred<Configuration, Configuration::Predicate>::get(level, configurationType) != nullptr;
                                                                                                            ^
../easylogging++.h: In member function ‘void el::Configurations::set(el::Level, el::ConfigurationType, const string&)’:
../easylogging++.h:2466:22: error: ‘Level’ is not a class or namespace
         if (level == Level::Global) {
                      ^
../easylogging++.h: In member function ‘void el::Configurations::set(el::Configuration*)’:
../easylogging++.h:2474:21: error: ‘nullptr’ was not declared in this scope
         if (conf == nullptr) {
                     ^
../easylogging++.h: In member function ‘void el::Configurations::setToDefault()’:
../easylogging++.h:2508:21: error: ‘ConfigurationType’ is not a class or namespace
         setGlobally(ConfigurationType::Enabled, "true", true);
                     ^
../easylogging++.h:2510:21: error: ‘ConfigurationType’ is not a class or namespace
         setGlobally(ConfigurationType::Filename, std::string(base::consts::kDefaultLogFile), true);
                     ^
../easylogging++.h:2514:21: error: ‘ConfigurationType’ is not a class or namespace
         setGlobally(ConfigurationType::ToFile, "true", true);
                     ^
../easylogging++.h:2515:21: error: ‘ConfigurationType’ is not a class or namespace
         setGlobally(ConfigurationType::ToStandardOutput, "true", true);
                     ^
../easylogging++.h:2516:21: error: ‘ConfigurationType’ is not a class or namespace
         setGlobally(ConfigurationType::MillisecondsWidth, "3", true);
                     ^
../easylogging++.h:2517:21: error: ‘ConfigurationType’ is not a class or namespace
         setGlobally(ConfigurationType::PerformanceTracking, "true", true);
                     ^
../easylogging++.h:2518:21: error: ‘ConfigurationType’ is not a class or namespace
         setGlobally(ConfigurationType::MaxLogFileSize, "0", true);
                     ^
../easylogging++.h:2519:21: error: ‘ConfigurationType’ is not a class or namespace
         setGlobally(ConfigurationType::LogFlushThreshold, "0", true);
                     ^
../easylogging++.h:2521:21: error: ‘ConfigurationType’ is not a class or namespace
         setGlobally(ConfigurationType::Format, "%datetime %level [%logger] %msg", true);
                     ^
../easylogging++.h:2522:13: error: ‘Level’ is not a class or namespace
         set(Level::Debug, ConfigurationType::Format, "%datetime %level [%logger] [%user@%host] [%func] [%loc] %msg");
             ^
../easylogging++.h:2522:27: error: ‘ConfigurationType’ is not a class or namespace
         set(Level::Debug, ConfigurationType::Format, "%datetime %level [%logger] [%user@%host] [%func] [%loc] %msg");
                           ^
../easylogging++.h:2524:13: error: ‘Level’ is not a class or namespace
         set(Level::Error, ConfigurationType::Format, "%datetime %level [%logger] %msg");
             ^
../easylogging++.h:2524:27: error: ‘ConfigurationType’ is not a class or namespace
         set(Level::Error, ConfigurationType::Format, "%datetime %level [%logger] %msg");
                           ^
../easylogging++.h:2525:13: error: ‘Level’ is not a class or namespace
         set(Level::Fatal, ConfigurationType::Format, "%datetime %level [%logger] %msg");
             ^
../easylogging++.h:2525:27: error: ‘ConfigurationType’ is not a class or namespace
         set(Level::Fatal, ConfigurationType::Format, "%datetime %level [%logger] %msg");
                           ^
../easylogging++.h:2526:13: error: ‘Level’ is not a class or namespace
         set(Level::Verbose, ConfigurationType::Format, "%datetime %level-%vlevel [%logger] %msg");
             ^
../easylogging++.h:2526:29: error: ‘ConfigurationType’ is not a class or namespace
         set(Level::Verbose, ConfigurationType::Format, "%datetime %level-%vlevel [%logger] %msg");
                             ^
../easylogging++.h:2527:13: error: ‘Level’ is not a class or namespace
         set(Level::Trace, ConfigurationType::Format, "%datetime %level [%logger] [%func] [%loc] %msg");
             ^
../easylogging++.h:2527:27: error: ‘ConfigurationType’ is not a class or namespace
         set(Level::Trace, ConfigurationType::Format, "%datetime %level [%logger] [%func] [%loc] %msg");
                           ^
../easylogging++.h: In member function ‘void el::Configurations::setRemainingToDefault()’:
../easylogging++.h:2539:29: error: ‘Level’ is not a class or namespace
         unsafeSetIfNotExist(Level::Global, ConfigurationType::Enabled, "true");
                             ^
../easylogging++.h:2539:44: error: ‘ConfigurationType’ is not a class or namespace
         unsafeSetIfNotExist(Level::Global, ConfigurationType::Enabled, "true");
                                            ^
../easylogging++.h:2541:29: error: ‘Level’ is not a class or namespace
         unsafeSetIfNotExist(Level::Global, ConfigurationType::Filename, std::string(base::consts::kDefaultLogFile));
                             ^
../easylogging++.h:2541:44: error: ‘ConfigurationType’ is not a class or namespace
         unsafeSetIfNotExist(Level::Global, ConfigurationType::Filename, std::string(base::consts::kDefaultLogFile));
                                            ^
../easylogging++.h:2543:29: error: ‘Level’ is not a class or namespace
         unsafeSetIfNotExist(Level::Global, ConfigurationType::ToFile, "true");
                             ^
../easylogging++.h:2543:44: error: ‘ConfigurationType’ is not a class or namespace
         unsafeSetIfNotExist(Level::Global, ConfigurationType::ToFile, "true");
                                            ^
../easylogging++.h:2544:29: error: ‘Level’ is not a class or namespace
         unsafeSetIfNotExist(Level::Global, ConfigurationType::ToStandardOutput, "true");
                             ^
../easylogging++.h:2544:44: error: ‘ConfigurationType’ is not a class or namespace
         unsafeSetIfNotExist(Level::Global, ConfigurationType::ToStandardOutput, "true");
                                            ^
../easylogging++.h:2545:29: error: ‘Level’ is not a class or namespace
         unsafeSetIfNotExist(Level::Global, ConfigurationType::MillisecondsWidth, "3");
                             ^
../easylogging++.h:2545:44: error: ‘ConfigurationType’ is not a class or namespace
         unsafeSetIfNotExist(Level::Global, ConfigurationType::MillisecondsWidth, "3");
                                            ^
../easylogging++.h:2546:29: error: ‘Level’ is not a class or namespace
         unsafeSetIfNotExist(Level::Global, ConfigurationType::PerformanceTracking, "true");
                             ^
../easylogging++.h:2546:44: error: ‘ConfigurationType’ is not a class or namespace
         unsafeSetIfNotExist(Level::Global, ConfigurationType::PerformanceTracking, "true");
                                            ^
../easylogging++.h:2547:29: error: ‘Level’ is not a class or namespace
         unsafeSetIfNotExist(Level::Global, ConfigurationType::MaxLogFileSize, "0");
                             ^
../easylogging++.h:2547:44: error: ‘ConfigurationType’ is not a class or namespace
         unsafeSetIfNotExist(Level::Global, ConfigurationType::MaxLogFileSize, "0");
                                            ^
../easylogging++.h:2548:29: error: ‘Level’ is not a class or namespace
         unsafeSetIfNotExist(Level::Global, ConfigurationType::Format, "%datetime %level [%logger] %msg");
                             ^
../easylogging++.h:2548:44: error: ‘ConfigurationType’ is not a class or namespace
         unsafeSetIfNotExist(Level::Global, ConfigurationType::Format, "%datetime %level [%logger] %msg");
                                            ^
../easylogging++.h:2549:29: error: ‘Level’ is not a class or namespace
         unsafeSetIfNotExist(Level::Debug, ConfigurationType::Format, 
                             ^
../easylogging++.h:2549:43: error: ‘ConfigurationType’ is not a class or namespace
         unsafeSetIfNotExist(Level::Debug, ConfigurationType::Format, 
                                           ^
../easylogging++.h:2552:29: error: ‘Level’ is not a class or namespace
         unsafeSetIfNotExist(Level::Error, ConfigurationType::Format, "%datetime %level [%logger] %msg");
                             ^
../easylogging++.h:2552:43: error: ‘ConfigurationType’ is not a class or namespace
         unsafeSetIfNotExist(Level::Error, ConfigurationType::Format, "%datetime %level [%logger] %msg");
                                           ^
../easylogging++.h:2553:29: error: ‘Level’ is not a class or namespace
         unsafeSetIfNotExist(Level::Fatal, ConfigurationType::Format, "%datetime %level [%logger] %msg");
                             ^
../easylogging++.h:2553:43: error: ‘ConfigurationType’ is not a class or namespace
         unsafeSetIfNotExist(Level::Fatal, ConfigurationType::Format, "%datetime %level [%logger] %msg");
                                           ^
../easylogging++.h:2554:29: error: ‘Level’ is not a class or namespace
         unsafeSetIfNotExist(Level::Verbose, ConfigurationType::Format, "%datetime %level-%vlevel [%logger] %msg");
                             ^
../easylogging++.h:2554:45: error: ‘ConfigurationType’ is not a class or namespace
         unsafeSetIfNotExist(Level::Verbose, ConfigurationType::Format, "%datetime %level-%vlevel [%logger] %msg");
                                             ^
../easylogging++.h:2555:29: error: ‘Level’ is not a class or namespace
         unsafeSetIfNotExist(Level::Trace, ConfigurationType::Format, "%datetime %level [%logger] [%func] [%loc] %msg");
                             ^
../easylogging++.h:2555:43: error: ‘ConfigurationType’ is not a class or namespace
         unsafeSetIfNotExist(Level::Trace, ConfigurationType::Format, "%datetime %level [%logger] [%func] [%loc] %msg");
                                           ^
../easylogging++.h: In static member function ‘static bool el::Configurations::Parser::parseFromFile(const string&, el::Configurations*, el::Configurations*)’:
../easylogging++.h:2577:31: error: ‘Level’ is not a class or namespace
             Level currLevel = Level::Unknown;
                               ^
../easylogging++.h: In static member function ‘static bool el::Configurations::Parser::parseFromText(const string&, el::Configurations*, el::Configurations*)’:
../easylogging++.h:2603:31: error: ‘Level’ is not a class or namespace
             Level currLevel = Level::Unknown;
                               ^
../easylogging++.h: In static member function ‘static bool el::Configurations::Parser::parseLine(std::string*, std::string*, std::string*, el::Level*, el::Configurations*)’:
../easylogging++.h:2650:44: error: ‘ConfigurationType’ is not a class or namespace
             ConfigurationType currConfig = ConfigurationType::Unknown;
                                            ^
In file included from ../main.cpp:12:0:
../easylogging++.h:2698:39: error: ‘Level’ is not a class or namespace
             ELPP_ASSERT(*currLevel != Level::Unknown, "Unrecognized severity level [" << *currLevelStr << "]");
                                       ^
../easylogging++.h:114:44: note: in definition of macro ‘ELPP_ASSERT’
 #      define ELPP_ASSERT(expr, msg) if (!(expr)) { \
                                            ^
../easylogging++.h:2699:39: error: ‘ConfigurationType’ is not a class or namespace
             ELPP_ASSERT(currConfig != ConfigurationType::Unknown, "Unrecognized configuration [" << *currConfigStr << "]");
                                       ^
../easylogging++.h:114:44: note: in definition of macro ‘ELPP_ASSERT’
 #      define ELPP_ASSERT(expr, msg) if (!(expr)) { \
                                            ^
In file included from ../main.cpp:12:0:
../easylogging++.h:2700:31: error: ‘Level’ is not a class or namespace
             if (*currLevel == Level::Unknown || currConfig == ConfigurationType::Unknown) {
                               ^
../easylogging++.h:2700:63: error: ‘ConfigurationType’ is not a class or namespace
             if (*currLevel == Level::Unknown || currConfig == ConfigurationType::Unknown) {
                                                               ^
../easylogging++.h: In member function ‘void el::Configurations::unsafeSetIfNotExist(el::Level, el::ConfigurationType, const string&)’:
../easylogging++.h:2716:21: error: ‘nullptr’ was not declared in this scope
         if (conf == nullptr) {
                     ^
../easylogging++.h: In member function ‘void el::Configurations::unsafeSet(el::Level, el::ConfigurationType, const string&)’:
../easylogging++.h:2724:21: error: ‘nullptr’ was not declared in this scope
         if (conf == nullptr) {
                     ^
../easylogging++.h:2729:22: error: ‘Level’ is not a class or namespace
         if (level == Level::Global) {
                      ^
../easylogging++.h: In member function ‘void el::Configurations::setGlobally(el::ConfigurationType, const string&, bool)’:
../easylogging++.h:2738:17: error: ‘Level’ is not a class or namespace
             set(Level::Global, configurationType, value);
                 ^
../easylogging++.h:2744:9: warning: lambda expressions only available with -std=c++11 or -std=gnu++11 [enabled by default]
         });
         ^
../easylogging++.h:2744:10: error: no matching function for call to ‘el::LevelHelper::forEachLevel(el::base::type::EnumType*, el::Configurations::setGlobally(el::ConfigurationType, const string&, bool)::__lambda1)’
         });
          ^
../easylogging++.h:2744:10: note: candidate is:
In file included from ../main.cpp:12:0:
../easylogging++.h:550:24: note: static void el::LevelHelper::forEachLevel(el::base::type::EnumType*, int)
     static inline void forEachLevel(base::type::EnumType* startIndex, const std::function<bool(void)>& fn) {
                        ^
../easylogging++.h:550:24: note:   no known conversion for argument 2 from ‘el::Configurations::setGlobally(el::ConfigurationType, const string&, bool)::__lambda1’ to ‘int’
In file included from ../main.cpp:12:0:
../easylogging++.h: In member function ‘void el::Configurations::unsafeSetGlobally(el::ConfigurationType, const string&, bool)’:
../easylogging++.h:2751:23: error: ‘Level’ is not a class or namespace
             unsafeSet(Level::Global, configurationType, value);
                       ^
../easylogging++.h:2757:9: warning: lambda expressions only available with -std=c++11 or -std=gnu++11 [enabled by default]
         });
         ^
../easylogging++.h:2757:10: error: no matching function for call to ‘el::LevelHelper::forEachLevel(el::base::type::EnumType*, el::Configurations::unsafeSetGlobally(el::ConfigurationType, const string&, bool)::__lambda2)’
         });
          ^
../easylogging++.h:2757:10: note: candidate is:
In file included from ../main.cpp:12:0:
../easylogging++.h:550:24: note: static void el::LevelHelper::forEachLevel(el::base::type::EnumType*, int)
     static inline void forEachLevel(base::type::EnumType* startIndex, const std::function<bool(void)>& fn) {
                        ^
../easylogging++.h:550:24: note:   no known conversion for argument 2 from ‘el::Configurations::unsafeSetGlobally(el::ConfigurationType, const string&, bool)::__lambda2’ to ‘int’
In file included from ../main.cpp:12:0:
../easylogging++.h: At global scope:
../easylogging++.h:2762:9: error: ‘shared_ptr’ in namespace ‘std’ does not name a type
 typedef std::shared_ptr<base::type::fstream_t> FileStreamPtr;
         ^
../easylogging++.h:2763:31: error: ‘FileStreamPtr’ was not declared in this scope
 typedef std::map<std::string, FileStreamPtr> LogStreamsReferenceMap;
                               ^
../easylogging++.h:2763:44: error: template argument 2 is invalid
 typedef std::map<std::string, FileStreamPtr> LogStreamsReferenceMap;
                                            ^
../easylogging++.h:2763:44: error: template argument 4 is invalid
../easylogging++.h:2763:68: error: invalid type in declaration before ‘;’ token
 typedef std::map<std::string, FileStreamPtr> LogStreamsReferenceMap;
                                                                    ^
../easylogging++.h:2843:21: error: ‘FileStreamPtr’ is not a member of ‘el::base’
     std::map<Level, base::FileStreamPtr> m_fileStreamMap;
                     ^
../easylogging++.h:2843:21: error: ‘FileStreamPtr’ is not a member of ‘el::base’
../easylogging++.h:2843:40: error: template argument 2 is invalid
     std::map<Level, base::FileStreamPtr> m_fileStreamMap;
                                        ^
../easylogging++.h:2843:40: error: template argument 4 is invalid
../easylogging++.h:3064:55: error: ‘PreRollOutCallback’ does not name a type
     bool unsafeValidateFileRolling(Level level, const PreRollOutCallback& PreRollOutCallback) {
                                                       ^
../easylogging++.h:3064:75: error: ISO C++ forbids declaration of ‘PreRollOutCallback’ with no type [-fpermissive]
     bool unsafeValidateFileRolling(Level level, const PreRollOutCallback& PreRollOutCallback) {
                                                                           ^
../easylogging++.h:3083:49: error: ‘PreRollOutCallback’ does not name a type
     bool validateFileRolling(Level level, const PreRollOutCallback& PreRollOutCallback) {
                                                 ^
../easylogging++.h:3083:69: error: ISO C++ forbids declaration of ‘PreRollOutCallback’ with no type [-fpermissive]
     bool validateFileRolling(Level level, const PreRollOutCallback& PreRollOutCallback) {
                                                                     ^
../easylogging++.h:2814:75: error: ‘Level’ is not a class or namespace
     inline const base::MillisecondsWidth& millisecondsWidth(Level level = Level::Global) {
                                                                           ^
../easylogging++.h:2818:51: error: ‘Level’ is not a class or namespace
     inline bool performanceTracking(Level level = Level::Global) {
                                                   ^
../easylogging++.h: In member function ‘el::base::type::fstream_t* el::base::TypedConfigurations::fileStream(el::Level)’:
../easylogging++.h:2823:31: error: ‘FileStreamPtr’ is not a member of ‘el::base’
         return getConfigByRef<base::FileStreamPtr>(level, &m_fileStreamMap, "fileStream").get();
                               ^
../easylogging++.h:2823:31: error: ‘FileStreamPtr’ is not a member of ‘el::base’
../easylogging++.h:2823:89: error: no matching function for call to ‘el::base::TypedConfigurations::getConfigByRef(el::Level&, int*, const char [11])’
         return getConfigByRef<base::FileStreamPtr>(level, &m_fileStreamMap, "fileStream").get();
                                                                                         ^
../easylogging++.h:2823:89: note: candidate is:
../easylogging++.h:2861:20: note: template<class Conf_T> Conf_T& el::base::TypedConfigurations::getConfigByRef(el::Level, std::map<el::Level, Conf_T>*, const char*)
     inline Conf_T& getConfigByRef(Level level, std::map<Level, Conf_T>* confMap, const char* confName) {
                    ^
../easylogging++.h:2861:20: note:   template argument deduction/substitution failed:
../easylogging++.h:2823:89: error: template argument 1 is invalid
         return getConfigByRef<base::FileStreamPtr>(level, &m_fileStreamMap, "fileStream").get();
                                                                                         ^
../easylogging++.h: In member function ‘Conf_T el::base::TypedConfigurations::unsafeGetConfigByVal(el::Level, const std::map<el::Level, Conf_T>*, const char*)’:
../easylogging++.h:2872:36: error: ‘Level’ is not a class or namespace
                 return confMap->at(Level::Global);
                                    ^
../easylogging++.h: In member function ‘Conf_T& el::base::TypedConfigurations::unsafeGetConfigByRef(el::Level, std::map<el::Level, Conf_T>*, const char*)’:
../easylogging++.h:2889:36: error: ‘Level’ is not a class or namespace
                 return confMap->at(Level::Global);
                                    ^
../easylogging++.h: In member function ‘void el::base::TypedConfigurations::setValue(el::Level, const Conf_T&, std::map<el::Level, Conf_T>*, bool)’:
../easylogging++.h:2903:44: error: ‘Level’ is not a class or namespace
             confMap->insert(std::make_pair(Level::Global, value));
                                            ^
../easylogging++.h:2907:71: error: ‘Level’ is not a class or namespace
         typename std::map<Level, Conf_T>::iterator it = confMap->find(Level::Global);
                                                                       ^
../easylogging++.h: In member function ‘void el::base::TypedConfigurations::build(el::Configurations*)’:
../easylogging++.h:2924:9: warning: ‘auto’ changes meaning in C++11; please remove it [-Wc++0x-compat]
         auto getBool = [] (std::string boolStr) -> bool {  // Pass by value for trimming
         ^
../easylogging++.h:2924:14: error: ‘getBool’ does not name a type
         auto getBool = [] (std::string boolStr) -> bool {  // Pass by value for trimming
              ^
../easylogging++.h:2932:46: error: ‘ConfigurationType’ is not a class or namespace
             if (conf->configurationType() == ConfigurationType::Enabled) {
                                              ^
../easylogging++.h:2933:62: error: ‘getBool’ was not declared in this scope
                 setValue(conf->level(), getBool(conf->value()), &m_enabledMap);
                                                              ^
../easylogging++.h:2934:53: error: ‘ConfigurationType’ is not a class or namespace
             } else if (conf->configurationType() == ConfigurationType::ToFile) {
                                                     ^
../easylogging++.h:2935:62: error: ‘getBool’ was not declared in this scope
                 setValue(conf->level(), getBool(conf->value()), &m_toFileMap);
                                                              ^
../easylogging++.h:2936:53: error: ‘ConfigurationType’ is not a class or namespace
             } else if (conf->configurationType() == ConfigurationType::ToStandardOutput) {
                                                     ^
../easylogging++.h:2937:62: error: ‘getBool’ was not declared in this scope
                 setValue(conf->level(), getBool(conf->value()), &m_toStandardOutputMap);
                                                              ^
../easylogging++.h:2938:53: error: ‘ConfigurationType’ is not a class or namespace
             } else if (conf->configurationType() == ConfigurationType::Filename) {
                                                     ^
../easylogging++.h:2944:53: error: ‘ConfigurationType’ is not a class or namespace
             } else if (conf->configurationType() == ConfigurationType::Format) {
                                                     ^
../easylogging++.h:2947:53: error: ‘ConfigurationType’ is not a class or namespace
             } else if (conf->configurationType() == ConfigurationType::MillisecondsWidth) {
                                                     ^
../easylogging++.h:2948:26: error: ‘Level’ is not a class or namespace
                 setValue(Level::Global, 
                          ^
../easylogging++.h:2950:53: error: ‘ConfigurationType’ is not a class or namespace
             } else if (conf->configurationType() == ConfigurationType::PerformanceTracking) {
                                                     ^
../easylogging++.h:2951:26: error: ‘Level’ is not a class or namespace
                 setValue(Level::Global, getBool(conf->value()), &m_performanceTrackingMap);
                          ^
../easylogging++.h:2951:62: error: ‘getBool’ was not declared in this scope
                 setValue(Level::Global, getBool(conf->value()), &m_performanceTrackingMap);
                                                              ^
../easylogging++.h:2952:53: error: ‘ConfigurationType’ is not a class or namespace
             } else if (conf->configurationType() == ConfigurationType::MaxLogFileSize) {
                                                     ^
../easylogging++.h:2957:53: error: ‘ConfigurationType’ is not a class or namespace
             } else if (conf->configurationType() == ConfigurationType::LogFlushThreshold) {
                                                     ^
../easylogging++.h:2964:46: error: ‘ConfigurationType’ is not a class or namespace
             if (conf->configurationType() == ConfigurationType::Filename) {
                                              ^
../easylogging++.h:2971:92: error: invalid conversion from ‘void (*)(const char*, std::size_t) {aka void (*)(const char*, long unsigned int)}’ to ‘int’ [-fpermissive]
                 unsafeValidateFileRolling((*conf)->level(), base::defaultPreRollOutCallback);
                                                                                            ^
../easylogging++.h:3064:10: error:   initializing argument 2 of ‘bool el::base::TypedConfigurations::unsafeValidateFileRolling(el::Level, const int&)’ [-fpermissive]
     bool unsafeValidateFileRolling(Level level, const PreRollOutCallback& PreRollOutCallback) {
          ^
../easylogging++.h: In member function ‘long unsigned int el::base::TypedConfigurations::getULong(std::string)’:
../easylogging++.h:2979:68: warning: lambda expressions only available with -std=c++11 or -std=gnu++11 [enabled by default]
                 [](char c) { return !base::utils::Str::isDigit(c); }) == confVal.end();
                                                                    ^
../easylogging++.h:2979:69: error: no matching function for call to ‘find_if(std::basic_string<char>::iterator, std::basic_string<char>::iterator, el::base::TypedConfigurations::getULong(std::string)::__lambda3)’
                 [](char c) { return !base::utils::Str::isDigit(c); }) == confVal.end();
                                                                     ^
../easylogging++.h:2979:69: note: candidate is:
In file included from /usr/include/c++/4.8/algorithm:62:0,
                 from ../easylogging++.h:315,
                 from ../main.cpp:12:
/usr/include/c++/4.8/bits/stl_algo.h:4456:5: note: template<class _IIter, class _Predicate> _IIter std::find_if(_IIter, _IIter, _Predicate)
     find_if(_InputIterator __first, _InputIterator __last,
     ^
/usr/include/c++/4.8/bits/stl_algo.h:4456:5: note:   template argument deduction/substitution failed:
In file included from ../main.cpp:12:0:
../easylogging++.h: In substitution of ‘template<class _IIter, class _Predicate> _IIter std::find_if(_IIter, _IIter, _Predicate) [with _IIter = __gnu_cxx::__normal_iterator<char*, std::basic_string<char> >; _Predicate = el::base::TypedConfigurations::getULong(std::string)::__lambda3]’:
../easylogging++.h:2979:69:   required from here
../easylogging++.h:2979:69: error: template argument for ‘template<class _IIter, class _Predicate> _IIter std::find_if(_IIter, _IIter, _Predicate)’ uses local type ‘el::base::TypedConfigurations::getULong(std::string)::__lambda3’
                 [](char c) { return !base::utils::Str::isDigit(c); }) == confVal.end();
                                                                     ^
../easylogging++.h:2979:69: error:   trying to instantiate ‘template<class _IIter, class _Predicate> _IIter std::find_if(_IIter, _IIter, _Predicate)’
../easylogging++.h: In member function ‘void el::base::TypedConfigurations::insertFile(el::Level, const string&)’:
../easylogging++.h:3037:9: warning: ‘auto’ changes meaning in C++11; please remove it [-Wc++0x-compat]
         auto create = [&](Level level) {
         ^
../easylogging++.h:3037:14: error: ‘create’ does not name a type
         auto create = [&](Level level) {
              ^
../easylogging++.h:3061:57: error: request for member ‘empty’ in ‘((el::base::TypedConfigurations*)this)->el::base::TypedConfigurations::m_fileStreamMap’, which is of non-class type ‘int’
         create(m_filenameMap.empty() && m_fileStreamMap.empty() ? Level::Global : level);
                                                         ^
../easylogging++.h:3061:67: error: ‘Level’ is not a class or namespace
         create(m_filenameMap.empty() && m_fileStreamMap.empty() ? Level::Global : level);
                                                                   ^
../easylogging++.h:3061:88: error: ‘create’ was not declared in this scope
         create(m_filenameMap.empty() && m_fileStreamMap.empty() ? Level::Global : level);
                                                                                        ^
../easylogging++.h: In member function ‘bool el::base::TypedConfigurations::unsafeValidateFileRolling(el::Level, const int&)’:
../easylogging++.h:3065:95: error: no matching function for call to ‘el::base::TypedConfigurations::unsafeGetConfigByRef(el::Level&, int*, const char [11])’
         base::type::fstream_t* fs = unsafeGetConfigByRef(level, &m_fileStreamMap, "fileStream").get();
                                                                                               ^
../easylogging++.h:3065:95: note: candidate is:
../easylogging++.h:2884:20: note: template<class Conf_T> Conf_T& el::base::TypedConfigurations::unsafeGetConfigByRef(el::Level, std::map<el::Level, Conf_T>*, const char*)
     inline Conf_T& unsafeGetConfigByRef(Level level, std::map<Level, Conf_T>* confMap, const char* confName) {
                    ^
../easylogging++.h:2884:20: note:   template argument deduction/substitution failed:
../easylogging++.h:3065:95: note:   mismatched types ‘std::map<el::Level, Conf_T>’ and ‘int’
         base::type::fstream_t* fs = unsafeGetConfigByRef(level, &m_fileStreamMap, "fileStream").get();
                                                                                               ^
../easylogging++.h:3066:19: error: ‘nullptr’ was not declared in this scope
         if (fs == nullptr) {
                   ^
../easylogging++.h:3076:59: error: expression cannot be used as a function
             PreRollOutCallback(fname.c_str(), currFileSize);
                                                           ^
../easylogging++.h:3077:68: error: no matching function for call to ‘std::basic_fstream<char>::open(std::string&, std::_Ios_Openmode)’
             fs->open(fname, std::fstream::out | std::fstream::trunc);
                                                                    ^
../easylogging++.h:3077:68: note: candidate is:
In file included from ../easylogging++.h:316:0,
                 from ../main.cpp:12:
/usr/include/c++/4.8/fstream:886:7: note: void std::basic_fstream<_CharT, _Traits>::open(const char*, std::ios_base::openmode) [with _CharT = char; _Traits = std::char_traits<char>; std::ios_base::openmode = std::_Ios_Openmode]
       open(const char* __s,
       ^
/usr/include/c++/4.8/fstream:886:7: note:   no known conversion for argument 1 from ‘std::string {aka std::basic_string<char>}’ to ‘const char*’
In file included from ../main.cpp:12:0:
../easylogging++.h: In member function ‘bool el::base::HitCounter::Predicate::operator()(const el::base::HitCounter*)’:
../easylogging++.h:3156:33: error: ‘nullptr’ was not declared in this scope
             return ((counter != nullptr) &&
                                 ^
../easylogging++.h: In instantiation of ‘class el::base::utils::AbstractRegistry<el::base::HitCounter, std::vector<el::base::HitCounter*, std::allocator<el::base::HitCounter*> > >’:
../easylogging++.h:1933:7:   required from ‘class el::base::utils::RegistryWithPred<el::base::HitCounter, el::base::HitCounter::Predicate>’
../easylogging++.h:3172:51:   required from here
../easylogging++.h:1784:23: error: cannot allocate an object of abstract type ‘el::base::utils::AbstractRegistry<el::base::HitCounter, std::vector<el::base::HitCounter*, std::allocator<el::base::HitCounter*> > >’
     AbstractRegistry& operator=(AbstractRegistry&& sr) {
                       ^
../easylogging++.h:1742:7: note:   because the following virtual functions are pure within ‘el::base::utils::AbstractRegistry<el::base::HitCounter, std::vector<el::base::HitCounter*, std::allocator<el::base::HitCounter*> > >’:
 class AbstractRegistry : public base::threading::ThreadSafe {
       ^
../easylogging++.h:1838:18: note: 	void el::base::utils::AbstractRegistry<T_Ptr, Container>::unregisterAll() [with T_Ptr = el::base::HitCounter; Container = std::vector<el::base::HitCounter*, std::allocator<el::base::HitCounter*> >]
     virtual void unregisterAll(void) = 0;
                  ^
../easylogging++.h:1841:18: note: 	void el::base::utils::AbstractRegistry<T_Ptr, Container>::deepCopy(const el::base::utils::AbstractRegistry<T_Ptr, Container>&) [with T_Ptr = el::base::HitCounter; Container = std::vector<el::base::HitCounter*, std::allocator<el::base::HitCounter*> >]
     virtual void deepCopy(const AbstractRegistry<T_Ptr, Container>&) = 0;
                  ^
../easylogging++.h: In member function ‘bool el::base::RegisteredHitCounters::validateEveryN(const char*, long unsigned int, std::size_t)’:
../easylogging++.h:3179:24: error: ‘nullptr’ was not declared in this scope
         if (counter == nullptr) {
                        ^
../easylogging++.h: In member function ‘bool el::base::RegisteredHitCounters::validateAfterN(const char*, long unsigned int, std::size_t)’:
../easylogging++.h:3192:24: error: ‘nullptr’ was not declared in this scope
         if (counter == nullptr) {
                        ^
../easylogging++.h: In member function ‘bool el::base::RegisteredHitCounters::validateNTimes(const char*, long unsigned int, std::size_t)’:
../easylogging++.h:3209:24: error: ‘nullptr’ was not declared in this scope
         if (counter == nullptr) {
                        ^
../easylogging++.h: At global scope:
../easylogging++.h:3226:1: warning: scoped enums only available with -std=c++11 or -std=gnu++11 [enabled by default]
 enum class DispatchAction : base::type::EnumType {
 ^
../easylogging++.h:3226:41: warning: scoped enums only available with -std=c++11 or -std=gnu++11 [enabled by default]
 enum class DispatchAction : base::type::EnumType {
                                         ^
../easylogging++.h: In constructor ‘el::LogDispatchData::LogDispatchData()’:
../easylogging++.h:3246:38: error: ‘nullptr’ was not declared in this scope
     LogDispatchData() : m_logMessage(nullptr), m_dispatchAction(base::DispatchAction::None) {}
                                      ^
../easylogging++.h:3246:71: error: ‘el::base::DispatchAction’ is not a class or namespace
     LogDispatchData() : m_logMessage(nullptr), m_dispatchAction(base::DispatchAction::None) {}
                                                                       ^
../easylogging++.h: In member function ‘void el::LogBuilder::convertToColoredOutput(el::base::type::string_t*, el::Level)’:
../easylogging++.h:3275:22: error: ‘Level’ is not a class or namespace
         if (level == Level::Error || level == Level::Fatal)
                      ^
../easylogging++.h:3275:47: error: ‘Level’ is not a class or namespace
         if (level == Level::Error || level == Level::Fatal)
                                               ^
../easylogging++.h:3277:27: error: ‘Level’ is not a class or namespace
         else if (level == Level::Warning)
                           ^
../easylogging++.h: At global scope:
../easylogging++.h:3281:9: error: ‘shared_ptr’ in namespace ‘std’ does not name a type
 typedef std::shared_ptr<LogBuilder> LogBuilderPtr;
         ^
../easylogging++.h:3407:37: error: ‘LogBuilderPtr’ does not name a type
     inline void setLogBuilder(const LogBuilderPtr& logBuilder) {
                                     ^
../easylogging++.h:3407:52: error: ISO C++ forbids declaration of ‘logBuilder’ with no type [-fpermissive]
     inline void setLogBuilder(const LogBuilderPtr& logBuilder) {
                                                    ^
../easylogging++.h:3422:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args> 
                                   ^
../easylogging++.h:3423:64: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     inline void verbose(int, const char*, const T&, const Args&...);
                                                                ^
../easylogging++.h:3417:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args>\
                                   ^
../easylogging++.h:3428:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS_SIGNATURES’
     LOGGER_LEVEL_WRITERS_SIGNATURES(info)
     ^
../easylogging++.h:3418:65: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     inline void FUNCTION_NAME(const char*, const T&, const Args&...);\
                                                                 ^
../easylogging++.h:3428:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS_SIGNATURES’
     LOGGER_LEVEL_WRITERS_SIGNATURES(info)
     ^
../easylogging++.h:3417:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args>\
                                   ^
../easylogging++.h:3429:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS_SIGNATURES’
     LOGGER_LEVEL_WRITERS_SIGNATURES(debug)
     ^
../easylogging++.h:3418:65: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     inline void FUNCTION_NAME(const char*, const T&, const Args&...);\
                                                                 ^
../easylogging++.h:3429:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS_SIGNATURES’
     LOGGER_LEVEL_WRITERS_SIGNATURES(debug)
     ^
../easylogging++.h:3417:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args>\
                                   ^
../easylogging++.h:3430:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS_SIGNATURES’
     LOGGER_LEVEL_WRITERS_SIGNATURES(warn)
     ^
../easylogging++.h:3418:65: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     inline void FUNCTION_NAME(const char*, const T&, const Args&...);\
                                                                 ^
../easylogging++.h:3430:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS_SIGNATURES’
     LOGGER_LEVEL_WRITERS_SIGNATURES(warn)
     ^
../easylogging++.h:3417:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args>\
                                   ^
../easylogging++.h:3431:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS_SIGNATURES’
     LOGGER_LEVEL_WRITERS_SIGNATURES(error)
     ^
../easylogging++.h:3418:65: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     inline void FUNCTION_NAME(const char*, const T&, const Args&...);\
                                                                 ^
../easylogging++.h:3431:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS_SIGNATURES’
     LOGGER_LEVEL_WRITERS_SIGNATURES(error)
     ^
../easylogging++.h:3417:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args>\
                                   ^
../easylogging++.h:3432:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS_SIGNATURES’
     LOGGER_LEVEL_WRITERS_SIGNATURES(fatal)
     ^
../easylogging++.h:3418:65: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     inline void FUNCTION_NAME(const char*, const T&, const Args&...);\
                                                                 ^
../easylogging++.h:3432:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS_SIGNATURES’
     LOGGER_LEVEL_WRITERS_SIGNATURES(fatal)
     ^
../easylogging++.h:3417:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args>\
                                   ^
../easylogging++.h:3433:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS_SIGNATURES’
     LOGGER_LEVEL_WRITERS_SIGNATURES(trace)
     ^
../easylogging++.h:3418:65: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     inline void FUNCTION_NAME(const char*, const T&, const Args&...);\
                                                                 ^
../easylogging++.h:3433:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS_SIGNATURES’
     LOGGER_LEVEL_WRITERS_SIGNATURES(trace)
     ^
../easylogging++.h:3445:5: error: ‘LogBuilderPtr’ does not name a type
     LogBuilderPtr m_logBuilder;
     ^
../easylogging++.h:3462:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args>
                                   ^
../easylogging++.h:3463:61: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     void log_(Level, int, const char*, const T&, const Args&...);
                                                             ^
../easylogging++.h:3468:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args>
                                   ^
../easylogging++.h:3469:55: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     void log(Level, const char*, const T&, const Args&...);
                                                       ^
../easylogging++.h: In constructor ‘el::Logger::Logger(const string&, el::base::LogStreamsReferenceMap*)’:
../easylogging++.h:3289:35: error: ‘nullptr’ was not declared in this scope
             m_typedConfigurations(nullptr),
                                   ^
../easylogging++.h: In constructor ‘el::Logger::Logger(const string&, const el::Configurations&, el::base::LogStreamsReferenceMap*)’:
../easylogging++.h:3298:35: error: ‘nullptr’ was not declared in this scope
             m_typedConfigurations(nullptr),
                                   ^
../easylogging++.h: In copy constructor ‘el::Logger::Logger(const el::Logger&)’:
../easylogging++.h:3307:9: error: ‘safeDelete’ is not a member of ‘el::base::utils’
         base::utils::safeDelete(m_typedConfigurations);
         ^
../easylogging++.h: In member function ‘el::Logger& el::Logger::operator=(const el::Logger&)’:
../easylogging++.h:3318:9: error: ‘safeDelete’ is not a member of ‘el::base::utils’
         base::utils::safeDelete(m_typedConfigurations);
         ^
../easylogging++.h: In destructor ‘virtual el::Logger::~Logger()’:
../easylogging++.h:3330:9: error: ‘safeDelete’ is not a member of ‘el::base::utils’
         base::utils::safeDelete(m_typedConfigurations);
         ^
../easylogging++.h: In member function ‘void el::Logger::configure(const el::Configurations&)’:
../easylogging++.h:3341:38: error: ‘nullptr’ was not declared in this scope
         if (m_typedConfigurations != nullptr) {
                                      ^
../easylogging++.h:3343:37: error: ‘Level’ is not a class or namespace
             if (c->hasConfiguration(Level::Global, ConfigurationType::Filename)) {
                                     ^
../easylogging++.h:3343:52: error: ‘ConfigurationType’ is not a class or namespace
             if (c->hasConfiguration(Level::Global, ConfigurationType::Filename)) {
                                                    ^
../easylogging++.h:3352:9: error: ‘safeDelete’ is not a member of ‘el::base::utils’
         base::utils::safeDelete(m_typedConfigurations);
         ^
../easylogging++.h: In lambda function:
../easylogging++.h:3398:53: error: ‘nullptr’ was not declared in this scope
             flush(LevelHelper::castFromInt(lIndex), nullptr);
                                                     ^
../easylogging++.h: In member function ‘void el::Logger::flush()’:
../easylogging++.h:3400:9: warning: lambda expressions only available with -std=c++11 or -std=gnu++11 [enabled by default]
         });
         ^
../easylogging++.h:3400:10: error: no matching function for call to ‘el::LevelHelper::forEachLevel(el::base::type::EnumType*, el::Logger::flush()::__lambda4)’
         });
          ^
../easylogging++.h:3400:10: note: candidate is:
In file included from ../main.cpp:12:0:
../easylogging++.h:550:24: note: static void el::LevelHelper::forEachLevel(el::base::type::EnumType*, int)
     static inline void forEachLevel(base::type::EnumType* startIndex, const std::function<bool(void)>& fn) {
                        ^
../easylogging++.h:550:24: note:   no known conversion for argument 2 from ‘el::Logger::flush()::__lambda4’ to ‘int’
In file included from ../main.cpp:12:0:
../easylogging++.h: In member function ‘el::LogBuilder* el::Logger::logBuilder() const’:
../easylogging++.h:3404:16: error: ‘m_logBuilder’ was not declared in this scope
         return m_logBuilder.get();
                ^
../easylogging++.h: In member function ‘void el::Logger::setLogBuilder(const int&)’:
../easylogging++.h:3408:9: error: ‘m_logBuilder’ was not declared in this scope
         m_logBuilder = logBuilder;
         ^
../easylogging++.h: In member function ‘void el::Logger::initUnflushedCount()’:
../easylogging++.h:3481:9: warning: lambda expressions only available with -std=c++11 or -std=gnu++11 [enabled by default]
         });
         ^
../easylogging++.h:3481:10: error: no matching function for call to ‘el::LevelHelper::forEachLevel(el::base::type::EnumType*, el::Logger::initUnflushedCount()::__lambda5)’
         });
          ^
../easylogging++.h:3481:10: note: candidate is:
In file included from ../main.cpp:12:0:
../easylogging++.h:550:24: note: static void el::LevelHelper::forEachLevel(el::base::type::EnumType*, int)
     static inline void forEachLevel(base::type::EnumType* startIndex, const std::function<bool(void)>& fn) {
                        ^
../easylogging++.h:550:24: note:   no known conversion for argument 2 from ‘el::Logger::initUnflushedCount()::__lambda5’ to ‘int’
In file included from ../main.cpp:12:0:
../easylogging++.h: In member function ‘void el::Logger::flush(el::Level, el::base::type::fstream_t*)’:
../easylogging++.h:3489:19: error: ‘nullptr’ was not declared in this scope
         if (fs == nullptr && m_typedConfigurations->toFile(level)) {
                   ^
../easylogging++.h:3492:19: error: ‘nullptr’ was not declared in this scope
         if (fs != nullptr) {
                   ^
../easylogging++.h: In member function ‘void el::Logger::resolveLoggerFormatSpec() const’:
../easylogging++.h:3510:9: warning: lambda expressions only available with -std=c++11 or -std=gnu++11 [enabled by default]
         });
         ^
../easylogging++.h:3510:10: error: no matching function for call to ‘el::LevelHelper::forEachLevel(el::base::type::EnumType*, el::Logger::resolveLoggerFormatSpec() const::__lambda6)’
         });
          ^
../easylogging++.h:3510:10: note: candidate is:
In file included from ../main.cpp:12:0:
../easylogging++.h:550:24: note: static void el::LevelHelper::forEachLevel(el::base::type::EnumType*, int)
     static inline void forEachLevel(base::type::EnumType* startIndex, const std::function<bool(void)>& fn) {
                        ^
../easylogging++.h:550:24: note:   no known conversion for argument 2 from ‘el::Logger::resolveLoggerFormatSpec() const::__lambda6’ to ‘int’
In file included from ../main.cpp:12:0:
../easylogging++.h: In instantiation of ‘class el::base::utils::AbstractRegistry<el::Logger, std::map<std::basic_string<char>, el::Logger*, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, el::Logger*> > > >’:
../easylogging++.h:1857:7:   required from ‘class el::base::utils::Registry<el::Logger, std::basic_string<char> >’
../easylogging++.h:3515:47:   required from here
../easylogging++.h:1784:23: error: cannot allocate an object of abstract type ‘el::base::utils::AbstractRegistry<el::Logger, std::map<std::basic_string<char>, el::Logger*, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, el::Logger*> > > >’
     AbstractRegistry& operator=(AbstractRegistry&& sr) {
                       ^
../easylogging++.h:1742:7: note:   because the following virtual functions are pure within ‘el::base::utils::AbstractRegistry<el::Logger, std::map<std::basic_string<char>, el::Logger*, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, el::Logger*> > > >’:
 class AbstractRegistry : public base::threading::ThreadSafe {
       ^
../easylogging++.h:1838:18: note: 	void el::base::utils::AbstractRegistry<T_Ptr, Container>::unregisterAll() [with T_Ptr = el::Logger; Container = std::map<std::basic_string<char>, el::Logger*, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, el::Logger*> > >]
     virtual void unregisterAll(void) = 0;
                  ^
../easylogging++.h:1841:18: note: 	void el::base::utils::AbstractRegistry<T_Ptr, Container>::deepCopy(const el::base::utils::AbstractRegistry<T_Ptr, Container>&) [with T_Ptr = el::Logger; Container = std::map<std::basic_string<char>, el::Logger*, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, el::Logger*> > >]
     virtual void deepCopy(const AbstractRegistry<T_Ptr, Container>&) = 0;
                  ^
../easylogging++.h: At global scope:
../easylogging++.h:3517:38: error: ‘LogBuilderPtr’ does not name a type
     explicit RegisteredLoggers(const LogBuilderPtr& defaultLogBuilder) :
                                      ^
../easylogging++.h:3517:53: error: ISO C++ forbids declaration of ‘defaultLogBuilder’ with no type [-fpermissive]
     explicit RegisteredLoggers(const LogBuilderPtr& defaultLogBuilder) :
                                                     ^
../easylogging++.h:3586:5: error: ‘LogBuilderPtr’ does not name a type
     LogBuilderPtr m_defaultLogBuilder;
     ^
../easylogging++.h: In constructor ‘el::base::RegisteredLoggers::RegisteredLoggers(const int&)’:
../easylogging++.h:3518:9: error: class ‘el::base::RegisteredLoggers’ does not have any field named ‘m_defaultLogBuilder’
         m_defaultLogBuilder(defaultLogBuilder) {
         ^
../easylogging++.h: In member function ‘el::Logger* el::base::RegisteredLoggers::get(const string&, bool)’:
../easylogging++.h:3538:24: error: ‘nullptr’ was not declared in this scope
         if (logger_ == nullptr && forceCreation) {
                        ^
../easylogging++.h:3545:22: error: ‘class el::Logger’ has no member named ‘m_logBuilder’
             logger_->m_logBuilder = m_defaultLogBuilder;
                      ^
../easylogging++.h:3545:37: error: ‘m_defaultLogBuilder’ was not declared in this scope
             logger_->m_logBuilder = m_defaultLogBuilder;
                                     ^
../easylogging++.h: In member function ‘bool el::base::RegisteredLoggers::remove(const string&)’:
../easylogging++.h:3556:23: error: ‘nullptr’ was not declared in this scope
         if (logger != nullptr) {
                       ^
../easylogging++.h: In member function ‘bool el::base::RegisteredLoggers::has(const string&)’:
../easylogging++.h:3563:34: error: ‘nullptr’ was not declared in this scope
         return get(id, false) != nullptr;
                                  ^
../easylogging++.h: In member function ‘void el::base::RegisteredLoggers::flushAll()’:
../easylogging++.h:3578:44: error: invalid use of qualified-name ‘::iterator’
         for (base::LogStreamsReferenceMap::iterator it = m_logStreamsReference.begin();
                                            ^
../easylogging++.h:3578:53: error: expected ‘;’ before ‘it’
         for (base::LogStreamsReferenceMap::iterator it = m_logStreamsReference.begin();
                                                     ^
../easylogging++.h:3578:53: error: ‘it’ was not declared in this scope
../easylogging++.h:3578:80: error: request for member ‘begin’ in ‘((el::base::RegisteredLoggers*)this)->el::base::RegisteredLoggers::m_logStreamsReference’, which is of non-class type ‘el::base::LogStreamsReferenceMap {aka int}’
         for (base::LogStreamsReferenceMap::iterator it = m_logStreamsReference.begin();
                                                                                ^
../easylogging++.h:3579:45: error: request for member ‘end’ in ‘((el::base::RegisteredLoggers*)this)->el::base::RegisteredLoggers::m_logStreamsReference’, which is of non-class type ‘el::base::LogStreamsReferenceMap {aka int}’
                 it != m_logStreamsReference.end(); ++it) {
                                             ^
../easylogging++.h:3579:50: error: expected ‘)’ before ‘;’ token
                 it != m_logStreamsReference.end(); ++it) {
                                                  ^
../easylogging++.h:3579:54: error: ‘it’ was not declared in this scope
                 it != m_logStreamsReference.end(); ++it) {
                                                      ^
../easylogging++.h:3579:56: error: expected ‘;’ before ‘)’ token
                 it != m_logStreamsReference.end(); ++it) {
                                                        ^
../easylogging++.h: In member function ‘void el::base::VRegistry::setModules(const char*)’:
../easylogging++.h:3614:9: warning: ‘auto’ changes meaning in C++11; please remove it [-Wc++0x-compat]
         auto addSuffix = [](std::stringstream& ss, const char* sfx, const char* prev) {
         ^
../easylogging++.h:3614:14: error: ‘addSuffix’ does not name a type
         auto addSuffix = [](std::stringstream& ss, const char* sfx, const char* prev) {
              ^
../easylogging++.h:3627:9: warning: ‘auto’ changes meaning in C++11; please remove it [-Wc++0x-compat]
         auto insert = [&](std::stringstream& ss, base::type::VerboseLevel level) {
         ^
../easylogging++.h:3627:14: error: ‘insert’ does not name a type
         auto insert = [&](std::stringstream& ss, base::type::VerboseLevel level) {
              ^
../easylogging++.h:3663:37: error: ‘insert’ was not declared in this scope
                     insert(ss, level);
                                     ^
../easylogging++.h:3680:29: error: ‘insert’ was not declared in this scope
             insert(ss, level);
                             ^
../easylogging++.h: In member function ‘bool el::base::VRegistry::allowed(el::base::type::VerboseLevel, const char*)’:
../easylogging++.h:3686:42: error: ‘nullptr’ was not declared in this scope
         if (m_modules.empty() || file == nullptr) {
                                          ^
../easylogging++.h:3695:38: error: ‘LoggingFlag’ is not a class or namespace
             if (base::utils::hasFlag(LoggingFlag::AllowVerboseIfModuleNotSpecified, *m_pFlags)) {
                                      ^
../easylogging++.h: In member function ‘void el::base::VRegistry::setFromArgs(const el::base::utils::CommandLineArgs*)’:
../easylogging++.h:3715:43: error: ‘LoggingFlag’ is not a class or namespace
                 && (!base::utils::hasFlag(LoggingFlag::DisableVModules, *m_pFlags))) {
                                           ^
../easylogging++.h:3718:43: error: ‘LoggingFlag’ is not a class or namespace
                 && (!base::utils::hasFlag(LoggingFlag::DisableVModules, *m_pFlags))) {
                                           ^
../easylogging++.h: In constructor ‘el::LogMessage::LogMessage(el::Level, const string&, long unsigned int, const string&, el::base::type::VerboseLevel, el::Logger*)’:
../easylogging++.h:3734:77: error: ‘move’ is not a member of ‘std’
                   m_verboseLevel(verboseLevel), m_logger(logger), m_message(std::move(logger->stream().str())) {
                                                                             ^
../easylogging++.h: At global scope:
../easylogging++.h:3756:28: error: ‘LogBuilderPtr’ does not name a type
     explicit Storage(const LogBuilderPtr& defaultLogBuilder) :
                            ^
../easylogging++.h:3756:43: error: ISO C++ forbids declaration of ‘defaultLogBuilder’ with no type [-fpermissive]
     explicit Storage(const LogBuilderPtr& defaultLogBuilder) :
                                           ^
../easylogging++.h:3836:45: error: ‘PreRollOutCallback’ does not name a type
     inline void setPreRollOutCallback(const PreRollOutCallback& callback) {
                                             ^
../easylogging++.h:3836:65: error: ISO C++ forbids declaration of ‘callback’ with no type [-fpermissive]
     inline void setPreRollOutCallback(const PreRollOutCallback& callback) {
                                                                 ^
../easylogging++.h:3844:12: error: ‘PreRollOutCallback’ does not name a type
     inline PreRollOutCallback& preRollOutCallback(void) {
            ^
../easylogging++.h:3915:5: error: ‘PreRollOutCallback’ does not name a type
     PreRollOutCallback m_preRollOutCallback;
     ^
../easylogging++.h:3916:27: error: ‘LogDispatchCallbackPtr’ is not a member of ‘el::base::type’
     std::map<std::string, base::type::LogDispatchCallbackPtr> m_logDispatchCallbacks;
                           ^
../easylogging++.h:3916:27: error: ‘LogDispatchCallbackPtr’ is not a member of ‘el::base::type’
../easylogging++.h:3916:61: error: template argument 2 is invalid
     std::map<std::string, base::type::LogDispatchCallbackPtr> m_logDispatchCallbacks;
                                                             ^
../easylogging++.h:3916:61: error: template argument 4 is invalid
../easylogging++.h:3917:27: error: ‘PerformanceTrackingCallbackPtr’ is not a member of ‘el::base::type’
     std::map<std::string, base::type::PerformanceTrackingCallbackPtr> m_performanceTrackingCallbacks;
                           ^
../easylogging++.h:3917:27: error: ‘PerformanceTrackingCallbackPtr’ is not a member of ‘el::base::type’
../easylogging++.h:3917:69: error: template argument 2 is invalid
     std::map<std::string, base::type::PerformanceTrackingCallbackPtr> m_performanceTrackingCallbacks;
                                                                     ^
../easylogging++.h:3917:69: error: template argument 4 is invalid
../easylogging++.h: In constructor ‘el::base::Storage::Storage(const int&)’:
../easylogging++.h:3761:9: error: class ‘el::base::Storage’ does not have any field named ‘m_preRollOutCallback’
         m_preRollOutCallback(base::defaultPreRollOutCallback) {
         ^
../easylogging++.h:3766:58: error: ‘ConfigurationType’ is not a class or namespace
         performanceLogger->configurations()->setGlobally(ConfigurationType::Format, "%datetime %level %msg");
                                                          ^
../easylogging++.h:3776:17: error: ‘LoggingFlag’ is not a class or namespace
         addFlag(LoggingFlag::AllowVerboseIfModuleNotSpecified);
                 ^
../easylogging++.h: In destructor ‘virtual el::base::Storage::~Storage()’:
../easylogging++.h:3783:9: error: ‘safeDelete’ is not a member of ‘el::base::utils’
         base::utils::safeDelete(m_registeredHitCounters);
         ^
../easylogging++.h:3784:9: error: ‘safeDelete’ is not a member of ‘el::base::utils’
         base::utils::safeDelete(m_registeredLoggers);
         ^
../easylogging++.h:3785:9: error: ‘safeDelete’ is not a member of ‘el::base::utils’
         base::utils::safeDelete(m_vRegistry);
         ^
../easylogging++.h: In member function ‘void el::base::Storage::setPreRollOutCallback(const int&)’:
../easylogging++.h:3837:9: error: ‘m_preRollOutCallback’ was not declared in this scope
         m_preRollOutCallback = callback;
         ^
../easylogging++.h: In member function ‘void el::base::Storage::unsetPreRollOutCallback()’:
../easylogging++.h:3841:9: error: ‘m_preRollOutCallback’ was not declared in this scope
         m_preRollOutCallback = base::defaultPreRollOutCallback;
         ^
../easylogging++.h: In member function ‘bool el::base::Storage::installLogDispatchCallback(const string&)’:
../easylogging++.h:3883:35: error: ‘LogDispatchCallbackPtr’ is not a member of ‘el::base::type’
         return installCallback<T, base::type::LogDispatchCallbackPtr>(id, &m_logDispatchCallbacks);
                                   ^
../easylogging++.h:3883:35: error: ‘LogDispatchCallbackPtr’ is not a member of ‘el::base::type’
../easylogging++.h: In member function ‘void el::base::Storage::uninstallLogDispatchCallback(const string&)’:
../easylogging++.h:3888:30: error: ‘LogDispatchCallbackPtr’ is not a member of ‘el::base::type’
         uninstallCallback<T, base::type::LogDispatchCallbackPtr>(id, &m_logDispatchCallbacks);
                              ^
../easylogging++.h:3888:30: error: ‘LogDispatchCallbackPtr’ is not a member of ‘el::base::type’
../easylogging++.h: In member function ‘T* el::base::Storage::logDispatchCallback(const string&)’:
../easylogging++.h:3892:28: error: ‘LogDispatchCallbackPtr’ is not a member of ‘el::base::type’
         return callback<T, base::type::LogDispatchCallbackPtr>(id, &m_logDispatchCallbacks);
                            ^
../easylogging++.h:3892:28: error: ‘LogDispatchCallbackPtr’ is not a member of ‘el::base::type’
../easylogging++.h: In member function ‘bool el::base::Storage::installPerformanceTrackingCallback(const string&)’:
../easylogging++.h:3897:35: error: ‘PerformanceTrackingCallbackPtr’ is not a member of ‘el::base::type’
         return installCallback<T, base::type::PerformanceTrackingCallbackPtr>(id, &m_performanceTrackingCallbacks);
                                   ^
../easylogging++.h:3897:35: error: ‘PerformanceTrackingCallbackPtr’ is not a member of ‘el::base::type’
../easylogging++.h: In member function ‘void el::base::Storage::uninstallPerformanceTrackingCallback(const string&)’:
../easylogging++.h:3902:31: error: ‘PerformanceTrackingCallbackPtr’ is not a member of ‘el::base::type’
          uninstallCallback<T, base::type::PerformanceTrackingCallbackPtr>(id, &m_performanceTrackingCallbacks);
                               ^
../easylogging++.h:3902:31: error: ‘PerformanceTrackingCallbackPtr’ is not a member of ‘el::base::type’
../easylogging++.h: In member function ‘T* el::base::Storage::performanceTrackingCallback(const string&)’:
../easylogging++.h:3907:28: error: ‘PerformanceTrackingCallbackPtr’ is not a member of ‘el::base::type’
         return callback<T, base::type::PerformanceTrackingCallbackPtr>(id, &m_performanceTrackingCallbacks);
                            ^
../easylogging++.h:3907:28: error: ‘PerformanceTrackingCallbackPtr’ is not a member of ‘el::base::type’
../easylogging++.h: In member function ‘void el::base::Storage::setApplicationArguments(int, char**)’:
../easylogging++.h:3936:27: error: ‘ConfigurationType’ is not a class or namespace
             c.setGlobally(ConfigurationType::Filename, m_commandLineArgs.getParamValue(base::consts::kDefaultLogFileParam));
                           ^
../easylogging++.h: In member function ‘T* el::base::Storage::callback(const string&, std::map<std::basic_string<char>, TPtr>*)’:
../easylogging++.h:3975:16: error: ‘nullptr’ was not declared in this scope
         return nullptr;
                ^
../easylogging++.h: At global scope:
../easylogging++.h:3978:21: error: ‘StoragePointer’ in namespace ‘el::base::type’ does not name a type
 extern _ELPP_EXPORT base::type::StoragePointer elStorage;
                     ^
../easylogging++.h:3989:39: error: expected ‘,’ or ‘...’ before ‘&&’ token
     void dispatch(base::type::string_t&& logLine) {
                                       ^
../easylogging++.h: In member function ‘virtual void el::base::DefaultLogDispatchCallback::handle(const el::LogDispatchData*)’:
../easylogging++.h:3984:18: error: ‘move’ is not a member of ‘std’
         dispatch(std::move(m_data->logMessage()->logger()->logBuilder()->build(m_data->logMessage(), 
                  ^
../easylogging++.h:3985:47: error: ‘el::base::DispatchAction’ is not a class or namespace
             m_data->dispatchAction() == base::DispatchAction::NormalLog)));
                                               ^
../easylogging++.h: In member function ‘void el::base::DefaultLogDispatchCallback::dispatch(el::base::type::string_t)’:
../easylogging++.h:3990:47: error: ‘el::base::DispatchAction’ is not a class or namespace
         if (m_data->dispatchAction() == base::DispatchAction::NormalLog) {
                                               ^
../easylogging++.h:3993:27: error: ‘nullptr’ was not declared in this scope
                 if (fs != nullptr) {
                           ^
../easylogging++.h:3994:31: error: ‘logLine’ was not declared in this scope
                     fs->write(logLine.c_str(), logLine.size());
                               ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4001:29: note: in expansion of macro ‘ELPP’
                         if (ELPP->hasFlag(LoggingFlag::ImmediateFlush) || (m_data->logMessage()->logger()->isFlushNeeded(m_data->logMessage()->level()))) {
                             ^
../easylogging++.h:4001:43: error: ‘LoggingFlag’ is not a class or namespace
                         if (ELPP->hasFlag(LoggingFlag::ImmediateFlush) || (m_data->logMessage()->logger()->isFlushNeeded(m_data->logMessage()->level()))) {
                                           ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4012:21: note: in expansion of macro ‘ELPP’
                 if (ELPP->hasFlag(LoggingFlag::ColoredTerminalOutput))
                     ^
../easylogging++.h:4012:35: error: ‘LoggingFlag’ is not a class or namespace
                 if (ELPP->hasFlag(LoggingFlag::ColoredTerminalOutput))
                                   ^
../easylogging++.h:4013:91: error: ‘logLine’ was not declared in this scope
                     m_data->logMessage()->logger()->logBuilder()->convertToColoredOutput(&logLine, m_data->logMessage()->level());
                                                                                           ^
In file included from ../main.cpp:12:0:
../easylogging++.h:4014:45: error: ‘logLine’ was not declared in this scope
                 ELPP_COUT << ELPP_COUT_LINE(logLine);
                                             ^
../easylogging++.h:442:36: note: in definition of macro ‘ELPP_COUT_LINE’
 #   define ELPP_COUT_LINE(logLine) logLine << std::flush
                                    ^
In file included from ../main.cpp:12:0:
../easylogging++.h: In member function ‘virtual el::base::type::string_t el::base::DefaultLogBuilder::build(const el::LogMessage*, bool) const’:
../easylogging++.h:4054:38: error: ‘el::base::FormatFlags’ is not a class or namespace
         if (logFormat->hasFlag(base::FormatFlags::AppName)) {
                                      ^
../easylogging++.h:4059:38: error: ‘el::base::FormatFlags’ is not a class or namespace
         if (logFormat->hasFlag(base::FormatFlags::ThreadId)) {
                                      ^
../easylogging++.h:4064:38: error: ‘el::base::FormatFlags’ is not a class or namespace
         if (logFormat->hasFlag(base::FormatFlags::DateTime)) {
                                      ^
../easylogging++.h:4070:38: error: ‘el::base::FormatFlags’ is not a class or namespace
         if (logFormat->hasFlag(base::FormatFlags::Function)) {
                                      ^
../easylogging++.h:4074:38: error: ‘el::base::FormatFlags’ is not a class or namespace
         if (logFormat->hasFlag(base::FormatFlags::File)) {
                                      ^
../easylogging++.h:4081:38: error: ‘el::base::FormatFlags’ is not a class or namespace
         if (logFormat->hasFlag(base::FormatFlags::Line)) {
                                      ^
../easylogging++.h:4088:38: error: ‘el::base::FormatFlags’ is not a class or namespace
         if (logFormat->hasFlag(base::FormatFlags::Location)) {
                                      ^
../easylogging++.h:4099:36: error: ‘Level’ is not a class or namespace
         if (logMessage->level() == Level::Verbose && logFormat->hasFlag(base::FormatFlags::VerboseLevel)) {
                                    ^
../easylogging++.h:4099:79: error: ‘el::base::FormatFlags’ is not a class or namespace
         if (logMessage->level() == Level::Verbose && logFormat->hasFlag(base::FormatFlags::VerboseLevel)) {
                                                                               ^
../easylogging++.h:4105:38: error: ‘el::base::FormatFlags’ is not a class or namespace
         if (logFormat->hasFlag(base::FormatFlags::LogMessage)) {
                                      ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4110:70: note: in expansion of macro ‘ELPP’
         for (std::vector<CustomFormatSpecifier>::const_iterator it = ELPP->customFormatSpecifiers()->begin();
                                                                      ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4111:23: note: in expansion of macro ‘ELPP’
                 it != ELPP->customFormatSpecifiers()->end(); ++it) {
                       ^
../easylogging++.h:4114:87: error: ‘const class el::CustomFormatSpecifier’ has no member named ‘resolver’
             base::utils::Str::replaceFirstWithEscape(logLine, wcsFormatSpecifier, it->resolver()());
                                                                                       ^
../easylogging++.h: At global scope:
../easylogging++.h:4124:43: error: expected ‘,’ or ‘...’ before ‘&&’ token
     LogDispatcher(bool proceed, LogMessage&& logMessage, base::DispatchAction dispatchAction) :
                                           ^
../easylogging++.h: In constructor ‘el::base::LogDispatcher::LogDispatcher(bool, el::LogMessage)’:
../easylogging++.h:4126:22: error: ‘move’ is not a member of ‘std’
         m_logMessage(std::move(logMessage)),
                      ^
../easylogging++.h:4126:32: error: ‘logMessage’ was not declared in this scope
         m_logMessage(std::move(logMessage)),
                                ^
../easylogging++.h:4127:26: error: ‘move’ is not a member of ‘std’
         m_dispatchAction(std::move(dispatchAction)) {
                          ^
../easylogging++.h:4127:36: error: ‘dispatchAction’ was not declared in this scope
         m_dispatchAction(std::move(dispatchAction)) {
                                    ^
../easylogging++.h: In member function ‘void el::base::LogDispatcher::dispatch()’:
../easylogging++.h:4131:52: error: ‘el::base::DispatchAction’ is not a class or namespace
         if (m_proceed && m_dispatchAction == base::DispatchAction::None) {
                                                    ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4138:48: note: in expansion of macro ‘ELPP’
         base::threading::ScopedLock scopedLock(ELPP->lock());
                                                ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4140:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::StrictLogFileSizeCheck)) {
             ^
../easylogging++.h:4140:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::StrictLogFileSizeCheck)) {
                           ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4141:59: note: in expansion of macro ‘ELPP’
             tc->validateFileRolling(m_logMessage.level(), ELPP->preRollOutCallback());
                                                           ^
../easylogging++.h:4143:41: error: ‘nullptr’ was not declared in this scope
         LogDispatchCallback* callback = nullptr;
                                         ^
../easylogging++.h:4145:43: error: ‘LogDispatchCallbackPtr’ is not a member of ‘el::base::type’
         for (const std::pair<std::string, base::type::LogDispatchCallbackPtr>& h 
                                           ^
../easylogging++.h:4145:43: error: ‘LogDispatchCallbackPtr’ is not a member of ‘el::base::type’
../easylogging++.h:4145:77: error: template argument 2 is invalid
         for (const std::pair<std::string, base::type::LogDispatchCallbackPtr>& h 
                                                                             ^
../easylogging++.h:4146:17: error: invalid type in declaration before ‘:’ token
                 : ELPP->m_logDispatchCallbacks) {
                 ^
../easylogging++.h:3979:14: error: range-based ‘for’ loops are not allowed in C++98 mode
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4146:19: note: in expansion of macro ‘ELPP’
                 : ELPP->m_logDispatchCallbacks) {
                   ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4146:19: note: in expansion of macro ‘ELPP’
                 : ELPP->m_logDispatchCallbacks) {
                   ^
../easylogging++.h:4147:26: error: request for member ‘second’ in ‘h’, which is of non-class type ‘const int’
             callback = h.second.get();
                          ^
../easylogging++.h: In constructor ‘el::base::MessageBuilder::MessageBuilder()’:
../easylogging++.h:4237:37: error: ‘nullptr’ was not declared in this scope
     MessageBuilder(void) : m_logger(nullptr), m_containerLogSeperator(ELPP_LITERAL("")) {}
                                     ^
../easylogging++.h: In member function ‘void el::base::MessageBuilder::initialize(el::Logger*)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4240:35: note: in expansion of macro ‘ELPP’
         m_containerLogSeperator = ELPP->hasFlag(LoggingFlag::NewLineForContainer) ? 
                                   ^
../easylogging++.h:4240:49: error: ‘LoggingFlag’ is not a class or namespace
         m_containerLogSeperator = ELPP->hasFlag(LoggingFlag::NewLineForContainer) ? 
                                                 ^
../easylogging++.h: In member function ‘el::base::MessageBuilder& el::base::MessageBuilder::operator<<(char)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4247:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
             ^
../easylogging++.h:4257:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(char)
     ^
../easylogging++.h:4247:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
                           ^
../easylogging++.h:4257:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(char)
     ^
../easylogging++.h: In member function ‘el::base::MessageBuilder& el::base::MessageBuilder::operator<<(bool)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4247:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
             ^
../easylogging++.h:4258:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(bool)
     ^
../easylogging++.h:4247:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
                           ^
../easylogging++.h:4258:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(bool)
     ^
../easylogging++.h: In member function ‘el::base::MessageBuilder& el::base::MessageBuilder::operator<<(short int)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4247:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
             ^
../easylogging++.h:4259:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(signed short)  // NOLINT
     ^
../easylogging++.h:4247:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
                           ^
../easylogging++.h:4259:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(signed short)  // NOLINT
     ^
../easylogging++.h: In member function ‘el::base::MessageBuilder& el::base::MessageBuilder::operator<<(short unsigned int)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4247:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
             ^
../easylogging++.h:4260:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(unsigned short)  // NOLINT
     ^
../easylogging++.h:4247:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
                           ^
../easylogging++.h:4260:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(unsigned short)  // NOLINT
     ^
../easylogging++.h: In member function ‘el::base::MessageBuilder& el::base::MessageBuilder::operator<<(int)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4247:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
             ^
../easylogging++.h:4261:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(signed int)
     ^
../easylogging++.h:4247:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
                           ^
../easylogging++.h:4261:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(signed int)
     ^
../easylogging++.h: In member function ‘el::base::MessageBuilder& el::base::MessageBuilder::operator<<(unsigned int)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4247:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
             ^
../easylogging++.h:4262:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(unsigned int)
     ^
../easylogging++.h:4247:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
                           ^
../easylogging++.h:4262:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(unsigned int)
     ^
../easylogging++.h: In member function ‘el::base::MessageBuilder& el::base::MessageBuilder::operator<<(long int)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4247:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
             ^
../easylogging++.h:4263:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(signed long)
     ^
../easylogging++.h:4247:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
                           ^
../easylogging++.h:4263:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(signed long)
     ^
../easylogging++.h: In member function ‘el::base::MessageBuilder& el::base::MessageBuilder::operator<<(long unsigned int)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4247:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
             ^
../easylogging++.h:4264:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(unsigned long)
     ^
../easylogging++.h:4247:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
                           ^
../easylogging++.h:4264:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(unsigned long)
     ^
../easylogging++.h: In member function ‘el::base::MessageBuilder& el::base::MessageBuilder::operator<<(float)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4247:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
             ^
../easylogging++.h:4265:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(float)
     ^
../easylogging++.h:4247:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
                           ^
../easylogging++.h:4265:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(float)
     ^
../easylogging++.h: In member function ‘el::base::MessageBuilder& el::base::MessageBuilder::operator<<(double)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4247:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
             ^
../easylogging++.h:4266:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(double)
     ^
../easylogging++.h:4247:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
                           ^
../easylogging++.h:4266:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(double)
     ^
../easylogging++.h: In member function ‘el::base::MessageBuilder& el::base::MessageBuilder::operator<<(char*)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4247:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
             ^
../easylogging++.h:4267:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(char*)
     ^
../easylogging++.h:4247:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
                           ^
../easylogging++.h:4267:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(char*)
     ^
../easylogging++.h: In member function ‘el::base::MessageBuilder& el::base::MessageBuilder::operator<<(const char*)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4247:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
             ^
../easylogging++.h:4268:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(const char*)
     ^
../easylogging++.h:4247:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
                           ^
../easylogging++.h:4268:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(const char*)
     ^
../easylogging++.h: In member function ‘el::base::MessageBuilder& el::base::MessageBuilder::operator<<(const void*)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4247:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
             ^
../easylogging++.h:4269:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(const void*)
     ^
../easylogging++.h:4247:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
                           ^
../easylogging++.h:4269:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(const void*)
     ^
../easylogging++.h: In member function ‘el::base::MessageBuilder& el::base::MessageBuilder::operator<<(long double)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4247:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
             ^
../easylogging++.h:4270:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(long double)
     ^
../easylogging++.h:4247:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
                           ^
../easylogging++.h:4270:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(long double)
     ^
../easylogging++.h: In member function ‘el::base::MessageBuilder& el::base::MessageBuilder::operator<<(const wchar_t*)’:
../easylogging++.h:4275:20: error: ‘nullptr’ was not declared in this scope
         if (msg == nullptr) {
                    ^
../easylogging++.h: In member function ‘el::base::MessageBuilder& el::base::MessageBuilder::operator<<(const Class&)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4247:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
             ^
../easylogging++.h:4533:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(const Class&)
     ^
../easylogging++.h:4247:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::AutoSpacing)) {\
                           ^
../easylogging++.h:4533:5: note: in expansion of macro ‘ELPP_SIMPLE_LOG’
     ELPP_SIMPLE_LOG(const Class&)
     ^
../easylogging++.h: At global scope:
../easylogging++.h:4577:78: error: ‘el::base::DispatchAction’ is not a class or namespace
                const char* func, base::DispatchAction dispatchAction = base::DispatchAction::NormalLog,
                                                                              ^
../easylogging++.h: In member function ‘el::base::Writer& el::base::Writer::construct(int, const char*, ...)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4614:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::MultiLoggerSupport)) {
             ^
../easylogging++.h:4614:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::MultiLoggerSupport)) {
                           ^
../easylogging++.h: In member function ‘void el::base::Writer::initializeLogger(const string&, bool, bool)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4645:24: note: in expansion of macro ‘ELPP’
             m_logger = ELPP->registeredLoggers()->get(loggerId, ELPP->hasFlag(LoggingFlag::CreateLoggerAutomatically));
                        ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4645:65: note: in expansion of macro ‘ELPP’
             m_logger = ELPP->registeredLoggers()->get(loggerId, ELPP->hasFlag(LoggingFlag::CreateLoggerAutomatically));
                                                                 ^
../easylogging++.h:4645:79: error: ‘LoggingFlag’ is not a class or namespace
             m_logger = ELPP->registeredLoggers()->get(loggerId, ELPP->hasFlag(LoggingFlag::CreateLoggerAutomatically));
                                                                               ^
../easylogging++.h:4647:25: error: ‘nullptr’ was not declared in this scope
         if (m_logger == nullptr) {
                         ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4648:13: note: in expansion of macro ‘ELPP’
             ELPP->acquireLock();
             ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4649:18: note: in expansion of macro ‘ELPP’
             if (!ELPP->registeredLoggers()->has(std::string(base::consts::kDefaultLoggerId))) {
                  ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4651:17: note: in expansion of macro ‘ELPP’
                 ELPP->registeredLoggers()->get(std::string(base::consts::kDefaultLoggerId));
                 ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4653:13: note: in expansion of macro ‘ELPP’
             ELPP->releaseLock();  // Need to unlock it for next writer
             ^
../easylogging++.h:4654:19: error: expected primary-expression before ‘(’ token
             Writer(Level::Debug, m_file, m_line, m_func).construct(1, base::consts::kDefaultLoggerId)
                   ^
../easylogging++.h:4654:20: error: ‘Level’ is not a class or namespace
             Writer(Level::Debug, m_file, m_line, m_func).construct(1, base::consts::kDefaultLoggerId)
                    ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4662:17: note: in expansion of macro ‘ELPP’
             if (ELPP->hasFlag(LoggingFlag::HierarchicalLogging)) {
                 ^
../easylogging++.h:4662:31: error: ‘LoggingFlag’ is not a class or namespace
             if (ELPP->hasFlag(LoggingFlag::HierarchicalLogging)) {
                               ^
../easylogging++.h:4663:40: error: ‘Level’ is not a class or namespace
                 m_proceed = m_level == Level::Verbose ? m_logger->enabled(m_level) :
                                        ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4664:83: note: in expansion of macro ‘ELPP’
                         LevelHelper::castToInt(m_level) >= LevelHelper::castToInt(ELPP->m_loggingLevel);
                                                                                   ^
../easylogging++.h: In member function ‘void el::base::Writer::processDispatch()’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4673:13: note: in expansion of macro ‘ELPP’
         if (ELPP->hasFlag(LoggingFlag::MultiLoggerSupport)) {
             ^
../easylogging++.h:4673:27: error: ‘LoggingFlag’ is not a class or namespace
         if (ELPP->hasFlag(LoggingFlag::MultiLoggerSupport)) {
                           ^
../easylogging++.h:4688:40: error: ‘nullptr’ was not declared in this scope
                 } else if (m_logger != nullptr) {
                                        ^
../easylogging++.h:4699:36: error: ‘nullptr’ was not declared in this scope
             } else if (m_logger != nullptr) {
                                    ^
../easylogging++.h: In member function ‘void el::base::Writer::triggerDispatch()’:
../easylogging++.h:4715:54: error: no matching function for call to ‘el::base::LogDispatcher::LogDispatcher(bool&, el::LogMessage, el::base::DispatchAction&)’
                           m_logger), m_dispatchAction).dispatch();
                                                      ^
../easylogging++.h:4715:54: note: candidates are:
../easylogging++.h:4124:5: note: el::base::LogDispatcher::LogDispatcher(bool, el::LogMessage)
     LogDispatcher(bool proceed, LogMessage&& logMessage, base::DispatchAction dispatchAction) :
     ^
../easylogging++.h:4124:5: note:   candidate expects 2 arguments, 3 provided
../easylogging++.h:4122:7: note: el::base::LogDispatcher::LogDispatcher(const el::base::LogDispatcher&)
 class LogDispatcher : base::NoCopy {
       ^
../easylogging++.h:4122:7: note:   candidate expects 1 argument, 3 provided
../easylogging++.h:4717:25: error: ‘nullptr’ was not declared in this scope
         if (m_logger != nullptr) {
                         ^
../easylogging++.h:4721:37: error: ‘Level’ is not a class or namespace
         if (m_proceed && m_level == Level::Fatal
                                     ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4722:21: note: in expansion of macro ‘ELPP’
                 && !ELPP->hasFlag(LoggingFlag::DisableApplicationAbortOnFatalLog)) {
                     ^
../easylogging++.h:4722:35: error: ‘LoggingFlag’ is not a class or namespace
                 && !ELPP->hasFlag(LoggingFlag::DisableApplicationAbortOnFatalLog)) {
                                   ^
../easylogging++.h:4723:25: error: expected primary-expression before ‘(’ token
             base::Writer(Level::Warning, m_file, m_line, m_func).construct(1, base::consts::kDefaultLoggerId)
                         ^
../easylogging++.h:4723:26: error: ‘Level’ is not a class or namespace
             base::Writer(Level::Warning, m_file, m_line, m_func).construct(1, base::consts::kDefaultLoggerId)
                          ^
../easylogging++.h: At global scope:
../easylogging++.h:4737:78: error: ‘el::base::DispatchAction’ is not a class or namespace
                const char* func, base::DispatchAction dispatchAction = base::DispatchAction::NormalLog,
                                                                              ^
../easylogging++.h:4757:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args>
                                   ^
../easylogging++.h:4758:94: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     void Logger::log_(Level level, int vlevel, const char* s, const T& value, const Args&... args) {
                                                                                              ^
../easylogging++.h: In member function ‘void el::Logger::log_(el::Level, int, const T&)’:
../easylogging++.h:4780:22: error: ‘Level’ is not a class or namespace
         if (level == Level::Verbose) {
                      ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4781:17: note: in expansion of macro ‘ELPP’
             if (ELPP->vRegistry()->allowed(vlevel, __FILE__)) {
                 ^
../easylogging++.h:4782:29: error: expected primary-expression before ‘(’ token
                 base::Writer(Level::Verbose, "FILE", 0, "FUNCTION", 
                             ^
../easylogging++.h:4782:30: error: ‘Level’ is not a class or namespace
                 base::Writer(Level::Verbose, "FILE", 0, "FUNCTION", 
                              ^
../easylogging++.h:4783:27: error: ‘el::base::DispatchAction’ is not a class or namespace
                     base::DispatchAction::NormalLog, vlevel).construct(this, false) << log;
                           ^
../easylogging++.h: At global scope:
../easylogging++.h:4791:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args>
                                   ^
../easylogging++.h:4792:81: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     void Logger::log(Level level, const char* s, const T& value, const Args&... args) {
                                                                                 ^
../easylogging++.h:4802:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args>
                                   ^
../easylogging++.h:4803:91: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     inline void Logger::verbose(int vlevel, const char* s, const T& value, const Args&... args) {
                                                                                           ^
../easylogging++.h: In member function ‘void el::Logger::verbose(int, const char*, const T&, const Args& ...)’:
../easylogging++.h:4805:18: error: ‘el::Level’ is not a class or namespace
         log_(el::Level::Verbose, vlevel, s, value, args...);
                  ^
../easylogging++.h: In member function ‘void el::Logger::verbose(int, const T&)’:
../easylogging++.h:4810:18: error: ‘el::Level’ is not a class or namespace
         log_(el::Level::Verbose, vlevel, log);
                  ^
../easylogging++.h: At global scope:
../easylogging++.h:4823:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args>\
                                   ^
../easylogging++.h:4842:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS’
     LOGGER_LEVEL_WRITERS(info, Level::Info)
     ^
../easylogging++.h:4824:85: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     inline void Logger::FUNCTION_NAME(const char* s, const T& value, const Args&... args) {\
                                                                                     ^
../easylogging++.h:4842:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS’
     LOGGER_LEVEL_WRITERS(info, Level::Info)
     ^
../easylogging++.h: In member function ‘void el::Logger::info(const char*, const T&, const Args& ...)’:
../easylogging++.h:4842:32: error: ‘Level’ is not a class or namespace
     LOGGER_LEVEL_WRITERS(info, Level::Info)
                                ^
../easylogging++.h:4825:13: note: in definition of macro ‘LOGGER_LEVEL_WRITERS’
         log(LOG_LEVEL, s, value, args...);\
             ^
../easylogging++.h: In member function ‘void el::Logger::info(const T&)’:
../easylogging++.h:4842:32: error: ‘Level’ is not a class or namespace
     LOGGER_LEVEL_WRITERS(info, Level::Info)
                                ^
../easylogging++.h:4829:13: note: in definition of macro ‘LOGGER_LEVEL_WRITERS’
         log(LOG_LEVEL, value);\
             ^
../easylogging++.h: At global scope:
../easylogging++.h:4823:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args>\
                                   ^
../easylogging++.h:4847:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS’
     LOGGER_LEVEL_WRITERS(debug, Level::Debug)
     ^
../easylogging++.h:4824:85: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     inline void Logger::FUNCTION_NAME(const char* s, const T& value, const Args&... args) {\
                                                                                     ^
../easylogging++.h:4847:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS’
     LOGGER_LEVEL_WRITERS(debug, Level::Debug)
     ^
../easylogging++.h: In member function ‘void el::Logger::debug(const char*, const T&, const Args& ...)’:
../easylogging++.h:4847:33: error: ‘Level’ is not a class or namespace
     LOGGER_LEVEL_WRITERS(debug, Level::Debug)
                                 ^
../easylogging++.h:4825:13: note: in definition of macro ‘LOGGER_LEVEL_WRITERS’
         log(LOG_LEVEL, s, value, args...);\
             ^
../easylogging++.h: In member function ‘void el::Logger::debug(const T&)’:
../easylogging++.h:4847:33: error: ‘Level’ is not a class or namespace
     LOGGER_LEVEL_WRITERS(debug, Level::Debug)
                                 ^
../easylogging++.h:4829:13: note: in definition of macro ‘LOGGER_LEVEL_WRITERS’
         log(LOG_LEVEL, value);\
             ^
../easylogging++.h: At global scope:
../easylogging++.h:4823:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args>\
                                   ^
../easylogging++.h:4852:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS’
     LOGGER_LEVEL_WRITERS(warn, Level::Warning)
     ^
../easylogging++.h:4824:85: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     inline void Logger::FUNCTION_NAME(const char* s, const T& value, const Args&... args) {\
                                                                                     ^
../easylogging++.h:4852:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS’
     LOGGER_LEVEL_WRITERS(warn, Level::Warning)
     ^
../easylogging++.h: In member function ‘void el::Logger::warn(const char*, const T&, const Args& ...)’:
../easylogging++.h:4852:32: error: ‘Level’ is not a class or namespace
     LOGGER_LEVEL_WRITERS(warn, Level::Warning)
                                ^
../easylogging++.h:4825:13: note: in definition of macro ‘LOGGER_LEVEL_WRITERS’
         log(LOG_LEVEL, s, value, args...);\
             ^
../easylogging++.h: In member function ‘void el::Logger::warn(const T&)’:
../easylogging++.h:4852:32: error: ‘Level’ is not a class or namespace
     LOGGER_LEVEL_WRITERS(warn, Level::Warning)
                                ^
../easylogging++.h:4829:13: note: in definition of macro ‘LOGGER_LEVEL_WRITERS’
         log(LOG_LEVEL, value);\
             ^
../easylogging++.h: At global scope:
../easylogging++.h:4823:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args>\
                                   ^
../easylogging++.h:4857:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS’
     LOGGER_LEVEL_WRITERS(error, Level::Error)
     ^
../easylogging++.h:4824:85: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     inline void Logger::FUNCTION_NAME(const char* s, const T& value, const Args&... args) {\
                                                                                     ^
../easylogging++.h:4857:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS’
     LOGGER_LEVEL_WRITERS(error, Level::Error)
     ^
../easylogging++.h: In member function ‘void el::Logger::error(const char*, const T&, const Args& ...)’:
../easylogging++.h:4857:33: error: ‘Level’ is not a class or namespace
     LOGGER_LEVEL_WRITERS(error, Level::Error)
                                 ^
../easylogging++.h:4825:13: note: in definition of macro ‘LOGGER_LEVEL_WRITERS’
         log(LOG_LEVEL, s, value, args...);\
             ^
../easylogging++.h: In member function ‘void el::Logger::error(const T&)’:
../easylogging++.h:4857:33: error: ‘Level’ is not a class or namespace
     LOGGER_LEVEL_WRITERS(error, Level::Error)
                                 ^
../easylogging++.h:4829:13: note: in definition of macro ‘LOGGER_LEVEL_WRITERS’
         log(LOG_LEVEL, value);\
             ^
../easylogging++.h: At global scope:
../easylogging++.h:4823:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args>\
                                   ^
../easylogging++.h:4862:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS’
     LOGGER_LEVEL_WRITERS(fatal, Level::Fatal)
     ^
../easylogging++.h:4824:85: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     inline void Logger::FUNCTION_NAME(const char* s, const T& value, const Args&... args) {\
                                                                                     ^
../easylogging++.h:4862:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS’
     LOGGER_LEVEL_WRITERS(fatal, Level::Fatal)
     ^
../easylogging++.h: In member function ‘void el::Logger::fatal(const char*, const T&, const Args& ...)’:
../easylogging++.h:4862:33: error: ‘Level’ is not a class or namespace
     LOGGER_LEVEL_WRITERS(fatal, Level::Fatal)
                                 ^
../easylogging++.h:4825:13: note: in definition of macro ‘LOGGER_LEVEL_WRITERS’
         log(LOG_LEVEL, s, value, args...);\
             ^
../easylogging++.h: In member function ‘void el::Logger::fatal(const T&)’:
../easylogging++.h:4862:33: error: ‘Level’ is not a class or namespace
     LOGGER_LEVEL_WRITERS(fatal, Level::Fatal)
                                 ^
../easylogging++.h:4829:13: note: in definition of macro ‘LOGGER_LEVEL_WRITERS’
         log(LOG_LEVEL, value);\
             ^
../easylogging++.h: At global scope:
../easylogging++.h:4823:35: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     template <typename T, typename... Args>\
                                   ^
../easylogging++.h:4867:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS’
     LOGGER_LEVEL_WRITERS(trace, Level::Trace)
     ^
../easylogging++.h:4824:85: warning: variadic templates only available with -std=c++11 or -std=gnu++11 [enabled by default]
     inline void Logger::FUNCTION_NAME(const char* s, const T& value, const Args&... args) {\
                                                                                     ^
../easylogging++.h:4867:5: note: in expansion of macro ‘LOGGER_LEVEL_WRITERS’
     LOGGER_LEVEL_WRITERS(trace, Level::Trace)
     ^
../easylogging++.h: In member function ‘void el::Logger::trace(const char*, const T&, const Args& ...)’:
../easylogging++.h:4867:33: error: ‘Level’ is not a class or namespace
     LOGGER_LEVEL_WRITERS(trace, Level::Trace)
                                 ^
../easylogging++.h:4825:13: note: in definition of macro ‘LOGGER_LEVEL_WRITERS’
         log(LOG_LEVEL, s, value, args...);\
             ^
../easylogging++.h: In member function ‘void el::Logger::trace(const T&)’:
../easylogging++.h:4867:33: error: ‘Level’ is not a class or namespace
     LOGGER_LEVEL_WRITERS(trace, Level::Trace)
                                 ^
../easylogging++.h:4829:13: note: in definition of macro ‘LOGGER_LEVEL_WRITERS’
         log(LOG_LEVEL, value);\
             ^
../easylogging++.h: At global scope:
../easylogging++.h:4908:5: warning: scoped enums only available with -std=c++11 or -std=gnu++11 [enabled by default]
     enum class DataType : base::type::EnumType {
     ^
../easylogging++.h:4908:39: warning: scoped enums only available with -std=c++11 or -std=gnu++11 [enabled by default]
     enum class DataType : base::type::EnumType {
                                       ^
../easylogging++.h: In constructor ‘el::PerformanceTrackingData::PerformanceTrackingData(el::PerformanceTrackingData::DataType)’:
../easylogging++.h:4912:80: error: ‘nullptr’ was not declared in this scope
     explicit PerformanceTrackingData(DataType dataType) : m_performanceTracker(nullptr), m_dataType(dataType) {}
                                                                                ^
../easylogging++.h: At global scope:
../easylogging++.h:4948:55: error: ‘el::base::TimestampUnit’ is not a class or namespace
             base::TimestampUnit timestampUnit = base::TimestampUnit::Millisecond,
                                                       ^
../easylogging++.h: In constructor ‘el::base::PerformanceTracker::PerformanceTracker(const string&, el::base::TimestampUnit, const string&, bool, el::Level)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4956:33: note: in expansion of macro ‘ELPP’
         el::Logger* loggerPtr = ELPP->registeredLoggers()->get(loggerId, false);
                                 ^
../easylogging++.h:4957:34: error: ‘nullptr’ was not declared in this scope
         m_enabled = loggerPtr != nullptr && loggerPtr->m_typedConfigurations->performanceTracking(m_level);
                                  ^
../easylogging++.h: In destructor ‘virtual el::base::PerformanceTracker::~PerformanceTracker()’:
../easylogging++.h:4976:89: error: expected unqualified-id before ‘)’ token
                 PerformanceTrackingData data(PerformanceTrackingData::DataType::Complete);
                                                                                         ^
../easylogging++.h:4977:22: error: request for member ‘init’ in ‘el::base::data’, which is of non-class type ‘el::PerformanceTrackingData(...)’
                 data.init(this);
                      ^
../easylogging++.h:4978:22: error: request for member ‘m_formattedTimeTaken’ in ‘el::base::data’, which is of non-class type ‘el::PerformanceTrackingData(...)’
                 data.m_formattedTimeTaken = formattedTime;
                      ^
../easylogging++.h:4979:57: error: ‘nullptr’ was not declared in this scope
                 PerformanceTrackingCallback* callback = nullptr;
                                                         ^
../easylogging++.h:4980:51: error: ‘PerformanceTrackingCallbackPtr’ is not a member of ‘el::base::type’
                 for (const std::pair<std::string, base::type::PerformanceTrackingCallbackPtr>& h
                                                   ^
../easylogging++.h:4980:51: error: ‘PerformanceTrackingCallbackPtr’ is not a member of ‘el::base::type’
../easylogging++.h:4980:93: error: template argument 2 is invalid
                 for (const std::pair<std::string, base::type::PerformanceTrackingCallbackPtr>& h
                                                                                             ^
../easylogging++.h:4981:25: error: invalid type in declaration before ‘:’ token
                         : ELPP->m_performanceTrackingCallbacks) {
                         ^
../easylogging++.h:3979:14: error: range-based ‘for’ loops are not allowed in C++98 mode
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4981:27: note: in expansion of macro ‘ELPP’
                         : ELPP->m_performanceTrackingCallbacks) {
                           ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:4981:27: note: in expansion of macro ‘ELPP’
                         : ELPP->m_performanceTrackingCallbacks) {
                           ^
../easylogging++.h:4982:34: error: request for member ‘second’ in ‘h’, which is of non-class type ‘const int’
                     callback = h.second.get();
                                  ^
../easylogging++.h:4985:47: error: no matching function for call to ‘el::PerformanceTrackingCallback::handle(el::PerformanceTrackingData (*)(...))’
                         callback->handle(&data);
                                               ^
../easylogging++.h:4985:47: note: candidate is:
../easylogging++.h:3240:18: note: void el::Callback<T>::handle(const T*) [with T = el::PerformanceTrackingData]
     virtual void handle(const T* handlePtr) = 0;
                  ^
../easylogging++.h:3240:18: note:   no known conversion for argument 1 from ‘el::PerformanceTrackingData (*)(...)’ to ‘const el::PerformanceTrackingData*’
../easylogging++.h: In member function ‘void el::base::PerformanceTracker::checkpoint(const string&, const char*, long unsigned int, const char*)’:
../easylogging++.h:5002:87: error: expected unqualified-id before ‘)’ token
             PerformanceTrackingData data(PerformanceTrackingData::DataType::Checkpoint);
                                                                                       ^
../easylogging++.h:5003:18: error: request for member ‘init’ in ‘el::base::data’, which is of non-class type ‘el::PerformanceTrackingData(...)’
             data.init(this);
                  ^
../easylogging++.h:5004:18: error: request for member ‘m_checkpointId’ in ‘el::base::data’, which is of non-class type ‘el::PerformanceTrackingData(...)’
             data.m_checkpointId = id;
                  ^
../easylogging++.h:5005:18: error: request for member ‘m_file’ in ‘el::base::data’, which is of non-class type ‘el::PerformanceTrackingData(...)’
             data.m_file = file;
                  ^
../easylogging++.h:5006:18: error: request for member ‘m_line’ in ‘el::base::data’, which is of non-class type ‘el::PerformanceTrackingData(...)’
             data.m_line = line;
                  ^
../easylogging++.h:5007:18: error: request for member ‘m_func’ in ‘el::base::data’, which is of non-class type ‘el::PerformanceTrackingData(...)’
             data.m_func = func;
                  ^
../easylogging++.h:5008:18: error: request for member ‘m_formattedTimeTaken’ in ‘el::base::data’, which is of non-class type ‘el::PerformanceTrackingData(...)’
             data.m_formattedTimeTaken = formattedTime;
                  ^
../easylogging++.h:5009:53: error: ‘nullptr’ was not declared in this scope
             PerformanceTrackingCallback* callback = nullptr;
                                                     ^
../easylogging++.h:5010:47: error: ‘PerformanceTrackingCallbackPtr’ is not a member of ‘el::base::type’
             for (const std::pair<std::string, base::type::PerformanceTrackingCallbackPtr>& h
                                               ^
../easylogging++.h:5010:47: error: ‘PerformanceTrackingCallbackPtr’ is not a member of ‘el::base::type’
../easylogging++.h:5010:89: error: template argument 2 is invalid
             for (const std::pair<std::string, base::type::PerformanceTrackingCallbackPtr>& h
                                                                                         ^
../easylogging++.h:5011:21: error: invalid type in declaration before ‘:’ token
                     : ELPP->m_performanceTrackingCallbacks) {
                     ^
../easylogging++.h:3979:14: error: range-based ‘for’ loops are not allowed in C++98 mode
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5011:23: note: in expansion of macro ‘ELPP’
                     : ELPP->m_performanceTrackingCallbacks) {
                       ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5011:23: note: in expansion of macro ‘ELPP’
                     : ELPP->m_performanceTrackingCallbacks) {
                       ^
../easylogging++.h:5012:30: error: request for member ‘second’ in ‘h’, which is of non-class type ‘const int’
                 callback = h.second.get();
                              ^
../easylogging++.h:5015:43: error: no matching function for call to ‘el::PerformanceTrackingCallback::handle(el::PerformanceTrackingData (*)(...))’
                     callback->handle(&data);
                                           ^
../easylogging++.h:5015:43: note: candidate is:
../easylogging++.h:3240:18: note: void el::Callback<T>::handle(const T*) [with T = el::PerformanceTrackingData]
     virtual void handle(const T* handlePtr) = 0;
                  ^
../easylogging++.h:3240:18: note:   no known conversion for argument 1 from ‘el::PerformanceTrackingData (*)(...)’ to ‘const el::PerformanceTrackingData*’
../easylogging++.h: In member function ‘virtual void el::base::DefaultPerformanceTrackingCallback::handle(const el::PerformanceTrackingData*)’:
../easylogging++.h:5059:58: error: ‘el::PerformanceTrackingData::DataType’ is not a class or namespace
         if (data->dataType() == PerformanceTrackingData::DataType::Complete) {
                                                          ^
../easylogging++.h:4888:11: error: expected primary-expression before ‘(’ token
     writer(level, __FILE__, __LINE__, _ELPP_FUNC, dispatchAction).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)
           ^
../easylogging++.h:5060:13: note: in expansion of macro ‘_ELPP_WRITE_LOG’
             _ELPP_WRITE_LOG(el::base::Writer, m_data->performanceTracker()->level(), base::DispatchAction::NormalLog, data->loggerId().c_str()) 
             ^
../easylogging++.h:5060:92: error: ‘el::base::DispatchAction’ is not a class or namespace
             _ELPP_WRITE_LOG(el::base::Writer, m_data->performanceTracker()->level(), base::DispatchAction::NormalLog, data->loggerId().c_str()) 
                                                                                            ^
../easylogging++.h:4888:51: note: in definition of macro ‘_ELPP_WRITE_LOG’
     writer(level, __FILE__, __LINE__, _ELPP_FUNC, dispatchAction).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)
                                                   ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5069:18: note: in expansion of macro ‘ELPP’
             if (!ELPP->hasFlag(LoggingFlag::DisablePerformanceTrackingCheckpointComparison) && data->performanceTracker()->m_hasChecked) {
                  ^
../easylogging++.h:5069:32: error: ‘LoggingFlag’ is not a class or namespace
             if (!ELPP->hasFlag(LoggingFlag::DisablePerformanceTrackingCheckpointComparison) && data->performanceTracker()->m_hasChecked) {
                                ^
../easylogging++.h:5080:107: error: call to ‘el::base::Writer::Writer(el::Level, const char*, long unsigned int, const char*, el::base::DispatchAction, el::base::type::VerboseLevel)’ uses the default argument for parameter 5, which is not yet defined
             el::base::Writer(data->performanceTracker()->m_level, data->file(), data->line(), data->func()).construct(1, data->loggerId().c_str()) << ss.str();
                                                                                                           ^
../easylogging++.h: In function ‘std::string el::base::debug::crashReason(int)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5217:17: note: in expansion of macro ‘ELPP’
             if (ELPP->hasFlag(el::LoggingFlag::LogDetailedCrashReason)) {
                 ^
../easylogging++.h:5217:35: error: ‘el::LoggingFlag’ is not a class or namespace
             if (ELPP->hasFlag(el::LoggingFlag::LogDetailedCrashReason)) {
                                   ^
../easylogging++.h: In function ‘void el::base::debug::logCrashReason(int, bool, el::Level, const char*)’:
../easylogging++.h:4888:11: error: expected primary-expression before ‘(’ token
     writer(level, __FILE__, __LINE__, _ELPP_FUNC, dispatchAction).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)
           ^
../easylogging++.h:5242:5: note: in expansion of macro ‘_ELPP_WRITE_LOG’
     _ELPP_WRITE_LOG(el::base::Writer, level, base::DispatchAction::NormalLog, logger) << ss.str();
     ^
../easylogging++.h:5242:52: error: ‘el::base::DispatchAction’ is not a class or namespace
     _ELPP_WRITE_LOG(el::base::Writer, level, base::DispatchAction::NormalLog, logger) << ss.str();
                                                    ^
../easylogging++.h:4888:51: note: in definition of macro ‘_ELPP_WRITE_LOG’
     writer(level, __FILE__, __LINE__, _ELPP_FUNC, dispatchAction).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)
                                                   ^
../easylogging++.h: In function ‘void el::base::debug::defaultCrashHandler(int)’:
../easylogging++.h:5251:44: error: ‘Level’ is not a class or namespace
     base::debug::logCrashReason(sig, true, Level::Fatal, base::consts::kDefaultLoggerId);
                                            ^
../easylogging++.h: At global scope:
../easylogging++.h:5310:47: error: ‘el::base::type::StoragePointer’ has not been declared
     static inline void setStorage(base::type::StoragePointer storage) {
                                               ^
../easylogging++.h:5314:19: error: ‘StoragePointer’ in namespace ‘el::base::type’ does not name a type
     static inline base::type::StoragePointer storage() {
                   ^
../easylogging++.h:5357:56: error: ‘PreRollOutCallback’ does not name a type
     static inline void installPreRollOutCallback(const PreRollOutCallback& callback) {
                                                        ^
../easylogging++.h:5357:76: error: ISO C++ forbids declaration of ‘callback’ with no type [-fpermissive]
     static inline void installPreRollOutCallback(const PreRollOutCallback& callback) {
                                                                            ^
../easylogging++.h:5352:27: error: ‘Level’ is not a class or namespace
             Level level = Level::Fatal, const char* logger = base::consts::kDefaultLoggerId) {
                           ^
../easylogging++.h: In static member function ‘static void el::Helpers::setStorage(int)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5311:9: note: in expansion of macro ‘ELPP’
         ELPP = storage;
         ^
../easylogging++.h: In static member function ‘static void el::Helpers::setArgs(int, char**)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5319:9: note: in expansion of macro ‘ELPP’
         ELPP->setApplicationArguments(argc, argv);
         ^
../easylogging++.h: In static member function ‘static void el::Helpers::setArgs(int, const char**)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5323:9: note: in expansion of macro ‘ELPP’
         ELPP->setApplicationArguments(argc, const_cast<char**>(argv));
         ^
../easylogging++.h: In static member function ‘static void el::Helpers::crashAbort(int, const char*, long unsigned int)’:
../easylogging++.h:5337:27: error: ‘nullptr’ was not declared in this scope
         if (sourceFile != nullptr && strlen(sourceFile) > 0) {
                           ^
../easylogging++.h: In static member function ‘static void el::Helpers::installPreRollOutCallback(const int&)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5358:9: note: in expansion of macro ‘ELPP’
         ELPP->setPreRollOutCallback(callback);
         ^
../easylogging++.h: In static member function ‘static void el::Helpers::uninstallPreRollOutCallback()’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5362:9: note: in expansion of macro ‘ELPP’
         ELPP->unsetPreRollOutCallback();
         ^
../easylogging++.h: In static member function ‘static bool el::Helpers::installLogDispatchCallback(const string&)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5367:16: note: in expansion of macro ‘ELPP’
         return ELPP->installLogDispatchCallback<T>(id);
                ^
../easylogging++.h: In static member function ‘static void el::Helpers::uninstallLogDispatchCallback(const string&)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5372:9: note: in expansion of macro ‘ELPP’
         ELPP->uninstallLogDispatchCallback<T>(id);
         ^
../easylogging++.h: In static member function ‘static T* el::Helpers::logDispatchCallback(const string&)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5376:16: note: in expansion of macro ‘ELPP’
         return ELPP->logDispatchCallback<T>(id);
                ^
../easylogging++.h: In static member function ‘static bool el::Helpers::installPerformanceTrackingCallback(const string&)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5381:16: note: in expansion of macro ‘ELPP’
         return ELPP->installPerformanceTrackingCallback<T>(id);
                ^
../easylogging++.h: In static member function ‘static void el::Helpers::uninstallPerformanceTrackingCallback(const string&)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5386:9: note: in expansion of macro ‘ELPP’
         ELPP->uninstallPerformanceTrackingCallback<T>(id);
         ^
../easylogging++.h: In static member function ‘static T* el::Helpers::performanceTrackingCallback(const string&)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5390:16: note: in expansion of macro ‘ELPP’
         return ELPP->performanceTrackingCallback<T>(id);
                ^
../easylogging++.h: In static member function ‘static std::string el::Helpers::convertTemplateToStdString(const T&)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5396:13: note: in expansion of macro ‘ELPP’
             ELPP->registeredLoggers()->get(el::base::consts::kDefaultLoggerId);
             ^
../easylogging++.h:5397:23: error: ‘nullptr’ was not declared in this scope
         if (logger == nullptr) {
                       ^
../easylogging++.h: In static member function ‘static const el::base::utils::CommandLineArgs* el::Helpers::commandLineArgs()’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5415:16: note: in expansion of macro ‘ELPP’
         return ELPP->commandLineArgs();
                ^
../easylogging++.h: In static member function ‘static void el::Helpers::installCustomFormatSpecifier(const el::CustomFormatSpecifier&)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5419:9: note: in expansion of macro ‘ELPP’
         ELPP->installCustomFormatSpecifier(customFormatSpecifier);
         ^
../easylogging++.h: In static member function ‘static bool el::Helpers::uninstallCustomFormatSpecifier(const char*)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5423:16: note: in expansion of macro ‘ELPP’
         return ELPP->uninstallCustomFormatSpecifier(formatSpecifier);
                ^
../easylogging++.h: In static member function ‘static bool el::Helpers::hasCustomFormatSpecifier(const char*)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5427:16: note: in expansion of macro ‘ELPP’
         return ELPP->hasCustomFormatSpecifier(formatSpecifier);
                ^
../easylogging++.h: In static member function ‘static void el::Helpers::validateFileRolling(el::Logger*, el::Level)’:
../easylogging++.h:5430:23: error: ‘nullptr’ was not declared in this scope
         if (logger == nullptr) return;
                       ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5431:67: note: in expansion of macro ‘ELPP’
         logger->m_typedConfigurations->validateFileRolling(level, ELPP->preRollOutCallback());
                                                                   ^
../easylogging++.h: In static member function ‘static el::Logger* el::Loggers::getLogger(const string&, bool)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5439:48: note: in expansion of macro ‘ELPP’
         base::threading::ScopedLock scopedLock(ELPP->lock());
                                                ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5440:16: note: in expansion of macro ‘ELPP’
         return ELPP->registeredLoggers()->get(identity, registerIfNotAvailable);
                ^
../easylogging++.h: In static member function ‘static bool el::Loggers::unregisterLogger(const string&)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5445:48: note: in expansion of macro ‘ELPP’
         base::threading::ScopedLock scopedLock(ELPP->lock());
                                                ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5446:16: note: in expansion of macro ‘ELPP’
         return ELPP->registeredLoggers()->remove(identity);
                ^
../easylogging++.h: In static member function ‘static bool el::Loggers::hasLogger(const string&)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5450:48: note: in expansion of macro ‘ELPP’
         base::threading::ScopedLock scopedLock(ELPP->lock());
                                                ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5451:16: note: in expansion of macro ‘ELPP’
         return ELPP->registeredLoggers()->has(identity);
                ^
../easylogging++.h: In static member function ‘static el::Logger* el::Loggers::reconfigureLogger(el::Logger*, const el::Configurations&)’:
../easylogging++.h:5455:29: error: ‘nullptr’ was not declared in this scope
         if (!logger) return nullptr;
                             ^
../easylogging++.h: In static member function ‘static el::Logger* el::Loggers::reconfigureLogger(const string&, el::ConfigurationType, const string&)’:
../easylogging++.h:5467:23: error: ‘nullptr’ was not declared in this scope
         if (logger == nullptr) {
                       ^
../easylogging++.h:5470:39: error: ‘Level’ is not a class or namespace
         logger->configurations()->set(Level::Global, configurationType, value);
                                       ^
../easylogging++.h: In static member function ‘static void el::Loggers::reconfigureAllLoggers(const el::Configurations&)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5476:53: note: in expansion of macro ‘ELPP’
         for (base::RegisteredLoggers::iterator it = ELPP->registeredLoggers()->begin();
                                                     ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5477:23: note: in expansion of macro ‘ELPP’
                 it != ELPP->registeredLoggers()->end(); ++it) {
                       ^
../easylogging++.h: In static member function ‘static void el::Loggers::reconfigureAllLoggers(el::ConfigurationType, const string&)’:
../easylogging++.h:5483:31: error: ‘Level’ is not a class or namespace
         reconfigureAllLoggers(Level::Global, configurationType, value);
                               ^
../easylogging++.h: In static member function ‘static void el::Loggers::reconfigureAllLoggers(el::Level, el::ConfigurationType, const string&)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5488:53: note: in expansion of macro ‘ELPP’
         for (base::RegisteredLoggers::iterator it = ELPP->registeredLoggers()->begin();
                                                     ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5489:23: note: in expansion of macro ‘ELPP’
                 it != ELPP->registeredLoggers()->end(); ++it) {
                       ^
../easylogging++.h: In static member function ‘static void el::Loggers::setDefaultConfigurations(const el::Configurations&, bool)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5497:9: note: in expansion of macro ‘ELPP’
         ELPP->registeredLoggers()->setDefaultConfigurations(configurations);
         ^
../easylogging++.h: In static member function ‘static const el::Configurations* el::Loggers::defaultConfigurations()’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5504:16: note: in expansion of macro ‘ELPP’
         return ELPP->registeredLoggers()->defaultConfigurations();
                ^
../easylogging++.h: In static member function ‘static const LogStreamsReferenceMap* el::Loggers::logStreamsReference()’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5508:16: note: in expansion of macro ‘ELPP’
         return ELPP->registeredLoggers()->logStreamsReference();
                ^
../easylogging++.h: In static member function ‘static el::base::TypedConfigurations el::Loggers::defaultTypedConfigurations()’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5513:13: note: in expansion of macro ‘ELPP’
             ELPP->registeredLoggers()->defaultConfigurations(),
             ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5514:13: note: in expansion of macro ‘ELPP’
             ELPP->registeredLoggers()->logStreamsReference());
             ^
../easylogging++.h: In static member function ‘static std::vector<std::basic_string<char> >* el::Loggers::populateAllLoggerIds(std::vector<std::basic_string<char> >*)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5520:53: note: in expansion of macro ‘ELPP’
         for (base::RegisteredLoggers::iterator it = ELPP->registeredLoggers()->list().begin();
                                                     ^
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5521:23: note: in expansion of macro ‘ELPP’
                 it != ELPP->registeredLoggers()->list().end(); ++it) {
                       ^
../easylogging++.h: In static member function ‘static void el::Loggers::configureFromGlobal(const char*)’:
../easylogging++.h:5533:26: error: ‘nullptr’ was not declared in this scope
         Logger* logger = nullptr;
                          ^
../easylogging++.h:5534:9: warning: ‘auto’ changes meaning in C++11; please remove it [-Wc++0x-compat]
         auto configure = [&](void) {
         ^
../easylogging++.h:5534:14: error: ‘configure’ does not name a type
         auto configure = [&](void) {
              ^
../easylogging++.h:5550:30: error: ‘configure’ was not declared in this scope
                    configure();
                              ^
../easylogging++.h:5564:23: error: ‘configure’ was not declared in this scope
             configure();
                       ^
../easylogging++.h: In static member function ‘static void el::Loggers::flushAll()’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5584:9: note: in expansion of macro ‘ELPP’
         ELPP->registeredLoggers()->flushAll();
         ^
../easylogging++.h: In static member function ‘static void el::Loggers::addFlag(el::LoggingFlag)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5588:9: note: in expansion of macro ‘ELPP’
         ELPP->addFlag(flag);
         ^
../easylogging++.h: In static member function ‘static void el::Loggers::removeFlag(el::LoggingFlag)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5592:9: note: in expansion of macro ‘ELPP’
         ELPP->removeFlag(flag);
         ^
../easylogging++.h: In static member function ‘static bool el::Loggers::hasFlag(el::LoggingFlag)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5596:16: note: in expansion of macro ‘ELPP’
         return ELPP->hasFlag(flag);
                ^
../easylogging++.h: In static member function ‘static void el::Loggers::setLoggingLevel(el::Level)’:
../easylogging++.h:3979:14: error: ‘elStorage’ is not a member of ‘el::base’
 #define ELPP el::base::elStorage
              ^
../easylogging++.h:5616:9: note: in expansion of macro ‘ELPP’
         ELPP->setLoggingLevel(level);
         ^
../easylogging++.h: In function ‘T* el::base::utils::checkNotNull(T*, const char*, const char*, ...)’:
../easylogging++.h:6182:20: error: ‘nullptr’ was not declared in this scope
     CLOG_IF(ptr == nullptr, FATAL, loggers) << "Check failed: [" << name << " != nullptr]";
                    ^
../easylogging++.h:4889:79: note: in definition of macro ‘_ELPP_WRITE_LOG_IF’
 #define _ELPP_WRITE_LOG_IF(writer, condition, level, dispatchAction, ...) if (condition) \
                                                                               ^
../easylogging++.h:5941:5: note: in expansion of macro ‘CFATAL_IF’
     C##LEVEL##_IF(el::base::Writer, condition, el::base::DispatchAction::NormalLog, __VA_ARGS__)
     ^
../easylogging++.h:6182:5: note: in expansion of macro ‘CLOG_IF’
     CLOG_IF(ptr == nullptr, FATAL, loggers) << "Check failed: [" << name << " != nullptr]";
     ^
../easylogging++.h:4890:11: error: expected primary-expression before ‘(’ token
     writer(level, __FILE__, __LINE__, _ELPP_FUNC, dispatchAction).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)
           ^
../easylogging++.h:5774:9: note: in expansion of macro ‘_ELPP_WRITE_LOG_IF’
         _ELPP_WRITE_LOG_IF(writer, (condition_), el::Level::Fatal, dispatchAction, __VA_ARGS__)
         ^
../easylogging++.h:5941:5: note: in expansion of macro ‘CFATAL_IF’
     C##LEVEL##_IF(el::base::Writer, condition, el::base::DispatchAction::NormalLog, __VA_ARGS__)
     ^
../easylogging++.h:6182:5: note: in expansion of macro ‘CLOG_IF’
     CLOG_IF(ptr == nullptr, FATAL, loggers) << "Check failed: [" << name << " != nullptr]";
     ^
../easylogging++.h:5774:54: error: ‘el::Level’ is not a class or namespace
         _ELPP_WRITE_LOG_IF(writer, (condition_), el::Level::Fatal, dispatchAction, __VA_ARGS__)
                                                      ^
../easylogging++.h:4890:12: note: in definition of macro ‘_ELPP_WRITE_LOG_IF’
     writer(level, __FILE__, __LINE__, _ELPP_FUNC, dispatchAction).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)
            ^
../easylogging++.h:5941:5: note: in expansion of macro ‘CFATAL_IF’
     C##LEVEL##_IF(el::base::Writer, condition, el::base::DispatchAction::NormalLog, __VA_ARGS__)
     ^
../easylogging++.h:6182:5: note: in expansion of macro ‘CLOG_IF’
     CLOG_IF(ptr == nullptr, FATAL, loggers) << "Check failed: [" << name << " != nullptr]";
     ^
../easylogging++.h:5941:58: error: ‘el::base::DispatchAction’ is not a class or namespace
     C##LEVEL##_IF(el::base::Writer, condition, el::base::DispatchAction::NormalLog, __VA_ARGS__)
                                                          ^
../easylogging++.h:4890:51: note: in definition of macro ‘_ELPP_WRITE_LOG_IF’
     writer(level, __FILE__, __LINE__, _ELPP_FUNC, dispatchAction).construct(el_getVALength(__VA_ARGS__), __VA_ARGS__)
                                                   ^
../easylogging++.h:5941:5: note: in expansion of macro ‘CFATAL_IF’
     C##LEVEL##_IF(el::base::Writer, condition, el::base::DispatchAction::NormalLog, __VA_ARGS__)
     ^
../easylogging++.h:6182:5: note: in expansion of macro ‘CLOG_IF’
     CLOG_IF(ptr == nullptr, FATAL, loggers) << "Check failed: [" << name << " != nullptr]";
     ^
../easylogging++.h: In instantiation of ‘void el::base::utils::RegistryWithPred<T_Ptr, Pred>::unregisterAll() [with T_Ptr = el::Configuration; Pred = el::Configuration::Predicate]’:
../easylogging++.h:2496:9:   required from here
../easylogging++.h:1974:13: warning: the address of ‘curr’ will always evaluate as ‘true’ [-Waddress]
             for (auto&& curr : this->list()) {
             ^
../easylogging++.h:1974:22: error: label ‘curr’ used but not defined
             for (auto&& curr : this->list()) {
                      ^
../easylogging++.h: In instantiation of ‘void el::base::utils::Registry<T_Ptr, T_Key>::unregisterAll() [with T_Ptr = el::Logger; T_Key = std::basic_string<char>]’:
../easylogging++.h:1884:23:   required from ‘el::base::utils::Registry<T_Ptr, T_Key>::~Registry() [with T_Ptr = el::Logger; T_Key = std::basic_string<char>]’
../easylogging++.h:3518:46:   required from here
../easylogging++.h:1890:13: warning: the address of ‘curr’ will always evaluate as ‘true’ [-Waddress]
             for (auto&& curr : this->list()) {
             ^
../easylogging++.h:1890:22: error: label ‘curr’ used but not defined
             for (auto&& curr : this->list()) {
                      ^
../easylogging++.h: In instantiation of ‘void el::base::utils::RegistryWithPred<T_Ptr, Pred>::unregisterAll() [with T_Ptr = el::base::HitCounter; Pred = el::base::HitCounter::Predicate]’:
../easylogging++.h:1942:23:   required from ‘el::base::utils::RegistryWithPred<T_Ptr, Pred>::~RegistryWithPred() [with T_Ptr = el::base::HitCounter; Pred = el::base::HitCounter::Predicate]’
../easylogging++.h:3172:7:   required from here
../easylogging++.h:1974:13: warning: the address of ‘curr’ will always evaluate as ‘true’ [-Waddress]
             for (auto&& curr : this->list()) {
             ^
../easylogging++.h:1974:22: error: label ‘curr’ used but not defined
             for (auto&& curr : this->list()) {
                      ^
../easylogging++.h: In instantiation of ‘el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator el::base::utils::AbstractRegistry<T_Ptr, Container>::cbegin() const [with T_Ptr = el::Logger; Container = std::map<std::basic_string<char>, el::Logger*, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, el::Logger*> > >; el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>, el::Logger*> >]’:
../main.cpp:17:1:   required from here
../easylogging++.h:1809:30: error: ‘const class std::map<std::basic_string<char>, el::Logger*, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, el::Logger*> > >’ has no member named ‘cbegin’
         return m_list.cbegin();
                              ^
../easylogging++.h: In instantiation of ‘el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator el::base::utils::AbstractRegistry<T_Ptr, Container>::cend() const [with T_Ptr = el::Logger; Container = std::map<std::basic_string<char>, el::Logger*, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, el::Logger*> > >; el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>, el::Logger*> >]’:
../main.cpp:17:1:   required from here
../easylogging++.h:1814:28: error: ‘const class std::map<std::basic_string<char>, el::Logger*, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, el::Logger*> > >’ has no member named ‘cend’
         return m_list.cend();
                            ^
../easylogging++.h: In instantiation of ‘el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator el::base::utils::AbstractRegistry<T_Ptr, Container>::cbegin() const [with T_Ptr = el::base::HitCounter; Container = std::vector<el::base::HitCounter*, std::allocator<el::base::HitCounter*> >; el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator = __gnu_cxx::__normal_iterator<el::base::HitCounter* const*, std::vector<el::base::HitCounter*, std::allocator<el::base::HitCounter*> > >]’:
../main.cpp:17:1:   required from here
../easylogging++.h:1809:30: error: ‘const class std::vector<el::base::HitCounter*, std::allocator<el::base::HitCounter*> >’ has no member named ‘cbegin’
         return m_list.cbegin();
                              ^
../easylogging++.h: In instantiation of ‘el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator el::base::utils::AbstractRegistry<T_Ptr, Container>::cend() const [with T_Ptr = el::base::HitCounter; Container = std::vector<el::base::HitCounter*, std::allocator<el::base::HitCounter*> >; el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator = __gnu_cxx::__normal_iterator<el::base::HitCounter* const*, std::vector<el::base::HitCounter*, std::allocator<el::base::HitCounter*> > >]’:
../main.cpp:17:1:   required from here
../easylogging++.h:1814:28: error: ‘const class std::vector<el::base::HitCounter*, std::allocator<el::base::HitCounter*> >’ has no member named ‘cend’
         return m_list.cend();
                            ^
../easylogging++.h: In instantiation of ‘el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator el::base::utils::AbstractRegistry<T_Ptr, Container>::cbegin() const [with T_Ptr = el::Configuration; Container = std::vector<el::Configuration*, std::allocator<el::Configuration*> >; el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator = __gnu_cxx::__normal_iterator<el::Configuration* const*, std::vector<el::Configuration*, std::allocator<el::Configuration*> > >]’:
../main.cpp:17:1:   required from here
../easylogging++.h:1809:30: error: ‘const class std::vector<el::Configuration*, std::allocator<el::Configuration*> >’ has no member named ‘cbegin’
         return m_list.cbegin();
                              ^
../easylogging++.h: In instantiation of ‘el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator el::base::utils::AbstractRegistry<T_Ptr, Container>::cend() const [with T_Ptr = el::Configuration; Container = std::vector<el::Configuration*, std::allocator<el::Configuration*> >; el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator = __gnu_cxx::__normal_iterator<el::Configuration* const*, std::vector<el::Configuration*, std::allocator<el::Configuration*> > >]’:
../main.cpp:17:1:   required from here
../easylogging++.h:1814:28: error: ‘const class std::vector<el::Configuration*, std::allocator<el::Configuration*> >’ has no member named ‘cend’
         return m_list.cend();
                            ^
../easylogging++.h: In static member function ‘static long long unsigned int el::base::utils::DateTime::getTimeDifference(const timeval&, const timeval&, el::base::TimestampUnit)’:
../easylogging++.h:1563:5: warning: control reaches end of non-void function [-Wreturn-type]
     }
     ^
../easylogging++.h: In member function ‘T_Ptr* el::base::utils::Registry<T_Ptr, T_Key>::get(const T_Key&) [with T_Ptr = el::Logger; T_Key = std::basic_string<char>]’:
../easylogging++.h:1918:5: warning: control reaches end of non-void function [-Wreturn-type]
     }
     ^
../easylogging++.h: In member function ‘el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator el::base::utils::AbstractRegistry<T_Ptr, Container>::cbegin() const [with T_Ptr = el::Logger; Container = std::map<std::basic_string<char>, el::Logger*, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, el::Logger*> > >; el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>, el::Logger*> >]’:
../easylogging++.h:1810:5: warning: control reaches end of non-void function [-Wreturn-type]
     }
     ^
../easylogging++.h: In member function ‘el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator el::base::utils::AbstractRegistry<T_Ptr, Container>::cend() const [with T_Ptr = el::Logger; Container = std::map<std::basic_string<char>, el::Logger*, std::less<std::basic_string<char> >, std::allocator<std::pair<const std::basic_string<char>, el::Logger*> > >; el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>, el::Logger*> >]’:
../easylogging++.h:1815:5: warning: control reaches end of non-void function [-Wreturn-type]
     }
     ^
../easylogging++.h: In member function ‘el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator el::base::utils::AbstractRegistry<T_Ptr, Container>::cbegin() const [with T_Ptr = el::base::HitCounter; Container = std::vector<el::base::HitCounter*, std::allocator<el::base::HitCounter*> >; el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator = __gnu_cxx::__normal_iterator<el::base::HitCounter* const*, std::vector<el::base::HitCounter*, std::allocator<el::base::HitCounter*> > >]’:
../easylogging++.h:1810:5: warning: control reaches end of non-void function [-Wreturn-type]
     }
     ^
../easylogging++.h: In member function ‘el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator el::base::utils::AbstractRegistry<T_Ptr, Container>::cend() const [with T_Ptr = el::base::HitCounter; Container = std::vector<el::base::HitCounter*, std::allocator<el::base::HitCounter*> >; el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator = __gnu_cxx::__normal_iterator<el::base::HitCounter* const*, std::vector<el::base::HitCounter*, std::allocator<el::base::HitCounter*> > >]’:
../easylogging++.h:1815:5: warning: control reaches end of non-void function [-Wreturn-type]
     }
     ^
../easylogging++.h: In member function ‘el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator el::base::utils::AbstractRegistry<T_Ptr, Container>::cbegin() const [with T_Ptr = el::Configuration; Container = std::vector<el::Configuration*, std::allocator<el::Configuration*> >; el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator = __gnu_cxx::__normal_iterator<el::Configuration* const*, std::vector<el::Configuration*, std::allocator<el::Configuration*> > >]’:
../easylogging++.h:1810:5: warning: control reaches end of non-void function [-Wreturn-type]
     }
     ^
../easylogging++.h: In member function ‘el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator el::base::utils::AbstractRegistry<T_Ptr, Container>::cend() const [with T_Ptr = el::Configuration; Container = std::vector<el::Configuration*, std::allocator<el::Configuration*> >; el::base::utils::AbstractRegistry<T_Ptr, Container>::const_iterator = __gnu_cxx::__normal_iterator<el::Configuration* const*, std::vector<el::Configuration*, std::allocator<el::Configuration*> > >]’:
../easylogging++.h:1815:5: warning: control reaches end of non-void function [-Wreturn-type]
     }
     ^
make: *** [main.o] Ошибка 1

09:33:28 Build Finished (took 1s.280ms)

